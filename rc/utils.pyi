# -*- coding: utf-8 -*-
"""Utils Module."""
import pathlib
from abc import ABCMeta
from abc import abstractmethod
from ast import AST as AST
from ast import AsyncFor as AsyncFor
from ast import AsyncFunctionDef as AsyncFunctionDef
from ast import AsyncWith as AsyncWith
from ast import Await as Await
from ast import ClassDef as ClassDef
from ast import FunctionDef as FunctionDef
from ast import get_source_segment as get_source_segment
from ast import Import as Import
from ast import ImportFrom as ImportFrom
from ast import NodeVisitor as NodeVisitor
from ast import walk as walk
from asyncio.events import _RunningLoop
from collections import defaultdict
from collections import deque
from enum import Enum
from functools import cache
from functools import partial
from functools import singledispatch
from functools import singledispatchmethod
from inspect import Attribute
from inspect import FrameInfo
from operator import attrgetter
from os import PathLike
from pathlib import Path as PathLib
from subprocess import CompletedProcess
from threading import _CRLock
from types import FrameType
from types import ModuleType
from types import TracebackType
from typing import _alias
from typing import Any
from typing import Callable
from typing import ChainMap
from typing import Generic
from typing import Iterable
from typing import Literal
from typing import MutableMapping
from typing import NamedTuple
from typing import Optional
from typing import OrderedDict
from typing import Protocol
from typing import runtime_checkable
from typing import Type
from typing import TypeVar
from typing import Union

from box import Box
from devtools import Debug
from environs import Env as Environs
from git import Repo as GitRepo
from git.refs import SymbolicReference as GitSymbolicReference
from icecream import IceCreamDebugger
from more_itertools import bucket
from rich import Console

_A = TypeVar('_A', bound='Attr')
_C = TypeVar('_C', bound='ChainRV')
_E = TypeVar('_E', bound='Executor')
_N = TypeVar('_N', bound='Name')
_T = TypeVar('_T')
_U = TypeVar('_U')
Bool = bool
Tuple = tuple

__all__: tuple
BUILTIN_CLASSES: Iterable[Type]
FRAME_SYS_INIT: FrameType
FUNCTION_MODULE: str
NEWLINE: str
PYTHON_SYS: str
PYTHON_SITE: pathlib.Path
Alias = _alias
CRLock: _CRLock
console: Console
debug: Debug
fmic: IceCreamDebugger().format
fmicc: IceCreamDebugger().format
ic: IceCreamDebugger
icc: IceCreamDebugger
POST_INIT_NAME: str
pp: console.print
print_exception: console.print_exception
RunningLoop = _RunningLoop

class pproperty(property):
    def __init__(self, fget: Callable = ..., fset: Callable = ..., fdel: Callable = ..., doc: str = ...) -> None: ...
Annotation = NamedTuple('Annotation', args=list[Type, ...], cls=Type, hints=dict, key=str, origin=Type)
class AnnotationsType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class AsDictClassMethodType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    @classmethod
    def asdict(cls, *args: Any, **kwargs: Any) -> dict[str, Any]: ...
class AsDictMethodType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    def asdict(self, *args: Any, **kwargs: Any) -> dict[str, Any]: ...
class AsDictPropertyType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    @property
    def asdict(self) -> dict[str, Any]: ...
class AsDictStaticMethodType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    @staticmethod
    def asdict(*args: Any, **kwargs: Any) -> dict[str, Any]: ...
class Attr(Enum, Generic[_A]):
    ALL: _A
    PRIVATE: _A
    PUBLIC: _A
    def include(self, obj: str) -> bool: ...
class Base:
    __slots__: tuple[str] = ...
    __hash_exclude__: tuple[str] = ...
    __ignore_attr__: tuple[str] = ...
    __ignore_copy__: tuple[str] = ...
    __ignore_kwarg__: tuple[str] = ...
    __ignore_str__: tuple[str] = ...
    __repr_exclude__: tuple[str] = ...
    __repr_newline__: bool = ...

    def __getattribute__(self, name: str, default: Any = ...) -> Any: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def get(self, name: str, default: Union[Any, partial] = ...) -> Any: ...
    def info(self,
             depth: Optional[int] = ...,
             ignore: bool = ...,
             key: Attr = ...) -> info: ...
class Base1:
    __slots__: tuple[str]
    __hash_exclude__: tuple[str]
    __repr_exclude__: tuple[str]
    def __getattribute__(self, name: str, default: Optional[Any, partial] = ...) -> Any: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def get(self, name: str, default: Union[Any, partial] = ...) -> Any: ...
    @property
    def cls_name(self) -> str: ...
    @staticmethod
    def get_mroattr(cls: Type, name: str = ...) -> set[str]: ...
    @classmethod
    def get_mrohash(cls) -> set[str]: ...
    @classmethod
    def get_mrorepr(cls) -> list[str]: ...
    @classmethod
    def get_mroslots(cls) -> set[str]: ...
    @staticmethod
    def get_propnew(name: str, default: Optional[Any, partial] = ...) -> property: ...
class BoxKeys(Box[str, str]):
    def __init__(self, keys: Iterable, lower: bool = ...) -> None: ...
class ChainRV(Enum):
    ALL: _C
    FIRST: _C
    UNIQUE: _C
class Chain(ChainMap):
    rv: ChainRV
    default: Any
    maps: list[Union[Iterable, NamedType, MutableMapping]]
    def __init__(self, *maps: ..., rv: ChainRV = ..., default: Any = ...) -> None: ...
    def __getitem__(self, key: str) -> Any: ...
    def __delitem__(self, key: str) -> None: ...
    def delete(self, key: str) -> None: ...
    def __setitem__(self, key: str, value: Any) -> None: ...
    def set(self, key: str, value: Any) -> None: ...
class Cls:
    __slots__: tuple[str] = ...
    data: Type = ...
    key: Attr = ...
    def __init__(self, data: Any = ..., key: Attr = ...) -> None: ...
    def __call__(self, data: Optional[Any] = ..., key: Optional[Attr] = ...) -> Cls: ...
    @cache
    def attr_value(self, name: str, default: Any = ...) -> dict[str, Attribute]: ...
    @property
    @cache
    def by_kind(self) -> bucket[defaultdict[str, deque[Attribute]]]: ...
    @property
    @cache
    def by_name(self) -> bucket[defaultdict[str, deque[Attribute]]]: ...
    @property
    @cache
    def callables(self) -> dict[str, Attribute]: ...
    @property
    @cache
    def classified(self) -> list[Attribute]: ...
    @property
    @cache
    def classmethods(self) -> list[str]: ...
    @property
    @cache
    def data_attrs(self) -> list[str]: ...
    @property
    @cache
    def dir(self) -> list[str]: ...
    def has_attr(self, name: str) -> bool: ...
    def has_method(self, name: str) -> bool: ...
    @property
    def has_reduce(self) -> bool: ...
    @property
    @cache
    def importable_name(self) -> str: ...
    def in_slot(self, name: str = ...) -> bool: ...
    @property
    @cache
    def methods(self) -> list[str]: ...
    @property
    def modname(self) -> str: ...
    @property
    @cache
    def mro(self) -> tuple[Type]: ...
    @cache
    def mroattr(self,
                name: Literal[
                '__hash_exclude__',
                '__ignore_attr__',
                '__ignore_copy__',
                '__ignore_kwarg__',
                '__ignore_str__',
                '__repr_exclude__',
                '__slots__', ] = ...,) -> set[str]: ...
    @cache
    def mroinclude(self,
                   name: Literal['__slots__'] = ...,
                   exclude: Literal['__hash_exclude__', '__repr_exclude__'] = ...,) -> set[str]: ...
    @property
    @cache
    def name(self) -> str: ...
    @property
    @cache
    def pproperties(self) -> list[str]: ...
    @property
    @cache
    def properties(self) -> list[str]: ...
    @staticmethod
    def propnew(name: str, default: Optional[Any, partial] = ...) -> property: ...
    @property
    def qualname(self) -> str: ...
    @property
    @cache
    def staticmethods(self) -> list[str]: ...
class CmdError(Exception):
    def __init__(self, rv: CompletedProcess) -> None: ...
class CmdAioError(CmdError):
    def __init__(self, rv: CompletedProcess) -> None: ...
class DataType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class DictType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class EnumDict(Enum):
    @classmethod
    def asdict(cls) -> dict: ...
    @classmethod
    def attrs(cls) -> list: ...
    @classmethod
    def default(cls) -> Any: ...
    @classmethod
    def default_attr(cls) -> str: ...
    @classmethod
    def default_dict(cls) -> dict: ...
    @classmethod
    def default_value(cls) -> Any: ...
    @property
    def describe(self) -> tuple: ...
    @property
    def lower(self) -> str: ...
    def prefix(self, prefix: str) -> str: ...
    @classmethod
    def values(cls) -> list: ...
EnumDictType: Alias
class Es:
    __slots__: Tuple[str] = ...
    data: Any = ...
    def __init__(self, data: Any = ...) -> None: ...
    def __call__(self, *args: Type) -> Bool: ...
    @property
    def asyncfor(self) -> Bool: ...
    @property
    def asyncfunctiondef(self) -> Bool: ...
    @property
    def asyncwith(self) -> Bool: ...
    @property
    def annotationstype(self) -> Bool: ...
    @property
    def annotationstype_sub(self) -> Bool: ...
    @property
    def asdict_classmethodtype(self) -> Bool: ...
    @property
    def asdict_classmethodtype_sub(self) -> Bool: ...
    @property
    def asdict_methodtype(self) -> Bool: ...
    @property
    def asdict_methodtype_sub(self) -> Bool: ...
    @property
    def asdict_propertytype(self) -> Bool: ...
    @property
    def asdict_propertytype_sub(self) -> Bool: ...
    @property
    def asdict_staticmethodtype(self) -> Bool: ...
    @property
    def asdict_staticmethodtype_sub(self) -> Bool: ...
    @property
    def ast(self) -> Bool: ...
    @property
    def asyncgen(self) -> Bool: ...
    @property
    def asyncgenfunc(self) -> Bool: ...
    def attr(self, name: str) -> Bool: ...
    @property
    def await_ast(self) -> Bool: ...
    @property
    def awaitable(self) -> Bool: ...
    @property
    def bool(self) -> Bool: ...
    @property
    def builtinfunctiontype(self) -> Bool: ...
    @property
    def binaryio(self) -> Bool: ...
    @property
    def chain(self) -> Bool: ...
    @property
    def chainmap(self) -> Bool: ...
    @property
    def classdef(self) -> Bool: ...
    @property
    def classmethod(self) -> Bool: ...
    @property
    def codetype(self) -> Bool: ...
    @property
    def collections(self) -> Bool: ...
    @property
    def coro(self) -> Bool: ...
    @property
    def coroutine(self) -> Bool: ...
    @property
    def coroutinefunc(self) -> Bool: ...
    @property
    def datatype(self) -> Bool: ...
    @property
    def datatype_sub(self) -> Bool: ...
    @property
    def defaultdict(self) -> Bool: ...
    @property
    def dict(self) -> Bool: ...
    @property
    def dicttype(self) -> Bool: ...
    @property
    def dicttype_sub(self) -> Bool: ...
    @property
    def dlst(self) -> Bool: ...
    @property
    def enum(self) -> Bool: ...
    @property
    def enum_sub(self) -> Bool: ...
    @property
    def enumdict(self) -> Bool: ...
    @property
    def enumdict_sub(self) -> Bool: ...
    @property
    def even(self) -> Bool: ...
    @property
    def float(self) -> Bool: ...
    @property
    def frameinfo(self) -> Bool: ...
    @property
    def frametype(self) -> Bool: ...
    @property
    def functiondef(self) -> Bool: ...
    @property
    def functiontype(self) -> Bool: ...
    @property
    def generator(self) -> Bool: ...
    @property
    def getattrnobuiltintype(self) -> Bool: ...
    @property
    def getattrnobuiltintype_sub(self) -> Bool: ...
    @property
    def getattrtype(self) -> Bool: ...
    @property
    def getattrtype_sub(self) -> Bool: ...
    @property
    def gettype(self) -> Bool: ...
    @property
    def gettype_sub(self) -> Bool: ...
    @property
    def getsetdescriptor(self) -> Bool: ...
    @property
    def hashable(self) -> Bool: ...
    @property
    def import_ast(self) -> Bool: ...
    @property
    def importfrom(self) -> Bool: ...
    @property
    def installed(self) -> Bool: ...
    def instance(self, *args: Type) -> Bool: ...
    @property
    def int(self) -> Bool: ...
    @property
    def io(self) -> Bool: ...
    @property
    def iterable(self) -> Bool: ...
    @property
    def iterator(self) -> Bool: ...
    @property
    def lambdatype(self) -> Bool: ...
    @property
    def list(self) -> Bool: ...
    @property
    def lst(self) -> Bool: ...
    @property
    def method(self) -> Bool: ...
    @property
    def methodwrappertype(self) -> Bool: ...
    @property
    def methodwrappertype_sub(self) -> Bool: ...
    @property
    def mlst(self) -> Bool: ...
    @property
    def mm(self) -> Bool: ...
    @property
    def moduletype(self) -> Bool: ...
    @property
    def module_function(self) -> Bool: ...
    @property
    def noncomplex(self) -> Bool: ...
    @property
    def namedtype(self) -> Bool: ...
    @property
    def namedtype_sub(self) -> Bool: ...
    @property
    def named_annotationstype(self) -> Bool: ...
    @property
    def named_annotationstype_sub(self) -> Bool: ...
    @property
    def object(self) -> Bool: ...
    @property
    def pathlib(self) -> Bool: ...
    def picklable(self, name: str) -> Bool: ...
    @property
    def primitive(self) -> Bool: ...
    @property
    def prop(self) -> Bool: ...
    @property
    def pproperty(self) -> Bool: ...
    @property
    def reducible(self) -> Bool: ...
    @property
    def reducible_sequence_subclass(self) -> Bool: ...
    @property
    def sequence(self) -> Bool: ...
    @property
    def sequence_subclass(self) -> Bool: ...
    @property
    def slotstype(self) -> Bool: ...
    @property
    def slotstype_sub(self) -> Bool: ...
    @property
    def staticmethod(self) -> Bool: ...
    @property
    def source(self) -> Bool: ...
    @property
    def textio(self) -> Bool: ...
    @property
    def tracebacktype(self) -> Bool: ...
    @property
    def tuple(self) -> Bool: ...
    @property
    def type(self) -> Bool: ...
    @property
    def unicode(self) -> Bool: ...
class Executor(Enum, Generic[_E]):
    PROCESS: _E
    THREAD: _E
    NONE: _E
    async def run(self, func: Any, *args: Any, **kwargs: Any) -> Any: ...
class GetAttrNoBuiltinType(metaclass=ABCMeta):
    def __getattribute__(self, name: str) -> Any: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class GetAttrType(metaclass=ABCMeta):
    def __getattribute__(self, name: str) -> Any: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
@runtime_checkable
class GetSupport(Protocol):
    __slots__: tuple
    @abstractmethod
    def get(self, name: str, default: Any = ...) -> Any: ...
class GetType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    def get(self, name: str, default: Any = ...) -> bool: ...
class Instance:
    __slots__: tuple[str] = ...
    data: Any = ...
    key: Attr = ...
    def __init__(self, data: Any = ..., key: Attr = ...) -> None:...
    def __call__(self, data: Optional[Any] = ..., key: Optional[Attr] = ...) -> Instance:...

    @cache
    def attr_value(self, name: str, default: Any = ...):...

    @property
    @cache
    def cls(self) -> Cls:...

    @property
    def dir(self) -> list[str]:...

    @property
    @cache
    def es(self) -> Es:...

    def has_attr(self, name: str) -> bool:...
    def has_method(self, name: str) -> bool:...
    @property
    def has_reduce(self) -> bool:...

    @property
    def hash(self) -> int:...

    @cache
    def mroattr(self,
                name: Literal[
                '__ignore_attr__',
                '__ignore_copy__',
                '__ignore_kwarg__',
                '__ignore_str__',] = ...,) -> set[str]:...
    def repr(self, newline: bool = ..., pprop: bool = ...) -> str:...
class Name(Enum, Generic[_N]):
    _all0: _N
    _class0: _N
    _annotations0: _N
    _builtins0: _N
    _cached0: _N
    _code0: _N
    _contains0: _N
    _dataclass_fields0: _N
    _dataclass_params0: _N
    _delattr0: _N
    _dir0: _N
    _dict0: _N
    _doc0: _N
    _eq0: _N
    _file0: _N
    _getattribute0: _N
    _hash_exclude0: _N
    _ignore_attr0: _N
    _ignore_str0: _N
    _len0: _N
    _loader0: _N
    _members0: _N
    _module0: _N
    _mro0: _N
    _name0: _N
    _package0: _N
    _qualname0: _N
    _reduce0: _N
    _repr0: _N
    _repr_exclude0: _N
    _setattr0: _N
    _slots0: _N
    _spec0: _N
    _str0: _N
    _asdict: _N
    add: _N
    append: _N
    asdict: _N
    cls_: _N
    clear: _N
    co_name: _N
    code_context: _N
    copy: _N
    count: _N
    data: _N
    endswith: _N
    extend: _N
    external: _N
    f_back: _N
    f_code: _N
    f_globals: _N
    f_lineno: _N
    f_locals: _N
    filename: _N
    frame: _N
    function: _N
    get_: _N
    globals: _N
    index: _N
    item: _N
    items: _N
    keys: _N
    kind: _N
    lineno: _N
    locals: _N
    name_: _N
    origin: _N
    obj: _N
    object: _N
    REPO: _N
    pop: _N
    popitem: _N
    PYPI: _N
    remove: _N
    reverse: _N
    self_: _N
    sort: _N
    startswith: _N
    tb_frame: _N
    tb_lineno: _N
    tb_next: _N
    update: _N
    value_: _N
    values: _N
    vars: _N
    @classmethod
    @cache
    def _attrs(cls) -> dict[bool, Iterable]: ...
    @classmethod
    @cache
    def attrs(cls) -> tuple: ...
    @singledispatchmethod
    def get(self, obj: Any, default: Any = ...) -> Any: ...
    @get.register
    def get_getattrtype(self, obj: GetAttrType, default: Any = ...) -> Any: ...
    @get.register
    def get_frameinfo(self, obj: FrameInfo, default: Any = ...) -> Any: ...
    @get.register
    def get_frametype(self, obj: FrameType, default: Any = ...) -> Any: ...
    @get.register
    def get_tracebacktype(self, obj: TracebackType, default: Any = ...) -> Any: ...
    @property
    @cache
    def getter(self) -> attrgetter: ...
    def has(self, obj: Any) -> bool: ...
    @classmethod
    def node(cls, obj: Any, complete: bool = ..., line: bool = ...) -> Union[tuple[AST, int], AST]: ...
    @classmethod
    def path(cls, obj: Any) -> PathLib: ...
    @classmethod
    @cache
    def private(cls) -> tuple: ...
    @classmethod
    @cache
    def public(cls) -> tuple: ...
    @classmethod
    @cache
    def _real(cls, name: str) -> str: ...
    @property
    def real(self) -> str: ...
    @classmethod
    def _source(cls, obj: Any, line: bool = ...) -> Optional[Union[tuple[str, int], str]]: ...
    @classmethod
    def source(cls, obj: Any, complete: bool = ..., line: bool = ...) -> Union[tuple[str, int], str]: ...
class NamedType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    def _asdict(self) -> dict[str, Any]: ...
class NamedAnnotationsType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class SlotsType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
def aioloop() -> Optional[RunningLoop]: ...
def allin(data: Iterable, dest: Iterable) -> bool: ...
def annotations(origin: Any, destination: int = ...) -> Union[dict[str, Annotation]: ...]: ...
def anyin(data: Iterable, dest: Iterable) -> Optional[Any]: ...
def cmd(command: Iterable,
        exc: bool = ...,
        lines: bool = ...,
        shell: bool = ...,
        py: bool = ...,
        pysite: bool = ...) -> Union[CompletedProcess, int, list, str]: ...
def cmdname(func: Callable, sep: str = ...) -> str: ...
def current_task_name() -> str: ...
@singledispatch
def delete(data: Union[MutableMapping, list], key: Iterable = ...) -> Optional[dict]: ...
@delete.register
def delete_list(data: list, key: Iterable = ...) -> Optional[list]: ...
def dict_sort(data: dict, ordered: bool = ..., reverse: bool = ...) -> Union[dict, OrderedDict]:...
@singledispatch
def get(data: Any, name: str, default: Any = ...) -> Any: ...
@get.register
def get_getattrtype(data: GetAttrType, name: str, default: Any = ...) -> Any: ...
def getset(data: Any, name: str, default: Any = ...) -> Any: ...
class info:
    __slots__: tuple[str] = ...
    __ignore_attr__: tuple[str] = ...
    __ignore_copy__: tuple[str] = ...
    __ignore_kwarg__: tuple[str] = ...
    __ignore_str__: tuple[str] = ...
    data: Any = ...
    depth: Optional[int] = ...
    ignore: bool = ...
    key: Attr = ...
    def __init__(self,
                 data: Any = ...,
                 depth: Optional[int] = ...,
                 ignore: bool = ...,
                 key: Attr = ...) -> None:...
    def __call__(self,
                 data: Optional[Any] = ...,
                 depth: Optional[int] = ...,
                 ignore: bool = ...,
                 key: Optional[Attr] = ...) -> info:...
    @cache
    def attr_value(self, name: str, default: Any = ...):...

    @property
    @cache
    def cls(self) -> Cls:...

    @property
    def dir(self) -> set[str]:...

    @property
    @cache
    def es(self) -> Es:...

    @property
    @cache
    def instance(self) -> Instance:...

    @property
    def module(self) -> ModuleType:...

    @cache
    def mroattr(self,
                name: Literal[
                '__ignore_attr__',
                '__ignore_copy__',
                '__ignore_kwarg__',
                '__ignore_str__',] = ...,) -> set[str]:...
    def has_attr(self, name: str) -> bool:...
    def has_method(self, name: str) -> bool:...
    @property
    def has_reduce(self) -> bool:...
def is_even(number: int) -> bool: ...
def join_newline(data: Iterable[str]) -> str: ...
def map_reduce_even(iterable: Iterable[_T]) -> list[_U, list[_T]]:...
def namedinit(cls: Type[Union[NamedAnnotationsType, NamedTuple]], optional: bool = ..., **kwargs) -> NamedTuple: ...
def noexception(
        exception: Union[tuple[Type[Exception]], Type[Exception]],
        func: Callable,
        *args,
        default_: Any = ...,
        **kwargs
) -> Any: ...
def prefixed(name: str) -> str: ...
def repr_format(obj: Any, attrs: Iterable[str], clear: bool = ..., newline: bool = ...) -> str: ...
def split_sep(sep: str = ...) -> dict: ...
def startswith(name: str, builtin: bool = ...) -> bool: ...
def to_iter(data: Any, exclude: Optional[Union[Type, tuple[Union[Type, tuple[Any, ...]], ...]]] = ...) -> list: ...
def token_open(file: Union[PathLike, PathLib, str]) -> str: ...
def varname(index: int = ..., lower: bool = ..., sep: str = ...) -> Optional[str]: ...
def black(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def blue(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def cyan(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def green(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def magenta(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
            blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def red(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
        blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def white(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def yellow(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bblack(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bblue(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bcyan(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bgreen(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bmagenta(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
             blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bred(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bwhite(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def byellow(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
            blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
