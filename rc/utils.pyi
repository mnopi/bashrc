# <editor-fold desc="Imports">
import functools
import pathlib
from abc import ABCMeta as ABCMeta
from abc import abstractmethod as abstractmethod
from ast import AST as AST
from ast import AsyncFor as AsyncFor
from ast import AsyncFunctionDef as AsyncFunctionDef
from ast import AsyncWith as AsyncWith
from ast import Await as Await
from ast import ClassDef as ClassDef
from ast import FunctionDef as FunctionDef
from ast import get_source_segment as get_source_segment
from ast import Import as Import
from ast import ImportFrom as ImportFrom
from ast import NodeVisitor as NodeVisitor
from ast import walk as walk
from asyncio import current_task as current_task
from asyncio import get_running_loop as get_running_loop
from asyncio import iscoroutine as iscoroutine
from asyncio.events import _RunningLoop
from collections import ChainMap as ChainMap
from collections import defaultdict as defaultdict
from collections import namedtuple as namedtuple
from collections import OrderedDict as OrderedDict
from collections.abc import AsyncGenerator as AsyncGenerator
from collections.abc import AsyncIterable as AsyncIterable
from collections.abc import AsyncIterator as AsyncIterator
from collections.abc import Awaitable as Awaitable
from collections.abc import ByteString as ByteString
from collections.abc import Callable as Callable
from collections.abc import Collection as Collection
from collections.abc import Container as Container
from collections.abc import Coroutine as Coroutine
from collections.abc import Generator as Generator
from collections.abc import Hashable as Hashable
from collections.abc import ItemsView as ItemsView
from collections.abc import Iterable as Iterable
from collections.abc import Iterator as Iterator
from collections.abc import KeysView as KeysView
from collections.abc import Mapping as Mapping
from collections.abc import MappingView as MappingView
from collections.abc import MutableMapping as MutableMapping
from collections.abc import MutableSequence as MutableSequence
from collections.abc import MutableSet as MutableSet
from collections.abc import Reversible as Reversible
from collections.abc import Sequence as Sequence
from collections.abc import Set as Set
from collections.abc import Sized as Sized
from collections.abc import ValuesView as ValuesView
from concurrent.futures.process import ProcessPoolExecutor as ProcessPoolExecutor
from concurrent.futures.thread import ThreadPoolExecutor as ThreadPoolExecutor
from contextlib import suppress as suppress
from dataclasses import _MISSING_TYPE
from dataclasses import dataclass as dataclass
from dataclasses import Field as DataField
from dataclasses import field as datafield
from dataclasses import fields as datafields
from dataclasses import InitVar as InitVar
from enum import auto as auto
from enum import Enum as Enum
from functools import cached_property as cached_property
from functools import partial as partial
from functools import singledispatch as singledispatch
from functools import singledispatchmethod as singledispatchmethod
from functools import wraps as wraps
from importlib import import_module as import_module
from inspect import classify_class_attrs as classify_class_attrs
from inspect import FrameInfo as FrameInfo
from inspect import getfile as getfile
from inspect import getsource as getsource
from inspect import getsourcefile as getsourcefile
from inspect import getsourcelines as getsourcelines
from inspect import isasyncgenfunction as isasyncgenfunction
from inspect import isawaitable as isawaitable
from inspect import iscoroutinefunction as iscoroutinefunction
from inspect import isgetsetdescriptor as isgetsetdescriptor
from inspect import ismemberdescriptor as ismemberdescriptor
from inspect import ismethoddescriptor as ismethoddescriptor
from inspect import isroutine as isroutine
from inspect import stack as insstack
from io import BytesIO as BytesIO
from io import FileIO as FileIO
from io import StringIO as StringIO
from operator import attrgetter as attrgetter
from os import PathLike as PathLike
from pathlib import Path as PathLib
from pickle import dump as pickle_dump
from pickle import dumps as pickle_dumps
from pickle import load as pickle_load
from pickle import loads as pickle_loads
from pickle import PicklingError as PicklingError
from subprocess import CompletedProcess as CompletedProcess
from threading import _CRLock
from threading import Lock as Lock
from timeit import timeit as timeit
from types import AsyncGeneratorType as AsyncGeneratorType
from types import BuiltinFunctionType as BuiltinFunctionType
from types import ClassMethodDescriptorType as ClassMethodDescriptorType
from types import CodeType as CodeType
from types import CoroutineType as CoroutineType
from types import DynamicClassAttribute as DynamicClassAttribute
from types import FrameType as FrameType
from types import FunctionType as FunctionType
from types import GeneratorType as GeneratorType
from types import GenericAlias as GenericAlias
from types import GetSetDescriptorType as GetSetDescriptorType
from types import LambdaType as LambdaType
from types import MappingProxyType as MappingProxyType
from types import MemberDescriptorType as MemberDescriptorType
from types import MethodType as MethodType
from types import MethodWrapperType as MethodWrapperType
from types import ModuleType as ModuleType
from types import SimpleNamespace as Simple
from types import TracebackType as TracebackType
from types import WrapperDescriptorType as WrapperDescriptorType
from typing import _alias
from typing import Any
from typing import AnyStr
from typing import ByteString
from typing import Callable
from typing import ChainMap
from typing import ClassVar
from typing import Final
from typing import Generator
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import KeysView
from typing import Literal
from typing import MutableMapping
from typing import MutableSequence
from typing import MutableSet
from typing import NamedTuple
from typing import NoReturn
from typing import Optional
from typing import OrderedDict
from typing import overload
from typing import Pattern
from typing import Protocol
from typing import runtime_checkable
from typing import Sequence
from typing import Sized
from typing import Type
from typing import TypeVar
from typing import Union
from typing import ValuesView
from warnings import catch_warnings as catch_warnings
from warnings import filterwarnings as filterwarnings

import jsonpickle.ext.numpy as pickle_np
import numpy as np
import pandas as pd
from astpretty import pprint as astprint
from astpretty import pformat as astformat
from box import Box as Box
from bson import ObjectId as ObjectId
from click import secho as secho
from click.exceptions import Exit as Exit
from decorator import decorator as decorator
from devtools import Debug as Debug
from dpath.util import delete as dpathdelete
from dpath.util import get as dpathget
from dpath.util import new as dpathnew
from dpath.util import set as dpathset
from dpath.util import search as dpathsearch
from dpath.util import values as dpathvalues
from environs import Env as Environs
from git import GitConfigParser as GitConfigParser
from git import Remote as Remote
from git import Repo as GitRepo
from git.refs import SymbolicReference as GitSymbolicReference
from icecream import IceCreamDebugger as IceCreamDebugger
from jsonpickle.pickler import Pickler as Pickler
from jsonpickle.unpickler import Unpickler as Unpickler
from more_itertools import collapse as collapse
from more_itertools import consume as consume
from more_itertools import first_true as first_true
from more_itertools import map_reduce as map_reduce
from more_itertools import side_effect as side_effect
from nested_lookup import nested_lookup as nested_lookup
from rich.console import Console as Console
from rich.pretty import install as pretty_install
from rich.traceback import install as traceback_install
from thefuck.utils import Cache as LazyCache
from thefuck.utils import memoize as memoize
from varname import varname as var_name
# </editor-fold>
# <editor-fold desc="TypeVars">
_Annotation = TypeVar('_Annotation', bound='Annotation')

_T = TypeVar('_T')
_U = TypeVar('_U')
_KT = TypeVar('_KT')  # Key type.
_VT = TypeVar('_VT')  # Value type.
_T_co = TypeVar('_T_co', covariant=True)  # Any type covariant containers.

# <editor-fold desc="Typing">
Bool = bool
Dict = dict
DictStrAny = dict[str, Any]
ExceptionUnion = Union[tuple[Type[Exception]], Type[Exception]]
LST = Union[MutableSequence, MutableSet, tuple]
SeqNoStr = Union[Iterator, KeysView, MutableSequence, MutableSet, tuple, ValuesView]
SeqUnion = Union[AnyStr, ByteString, Iterator, KeysView, MutableSequence, MutableSet, Sequence, tuple, ValuesView]
Str = str
Tuple = tuple
TupleStr = tuple[str, ...]
TupleType = tuple[Type, ...]
# </editor-fold>
# </editor-fold>
# <editor-fold desc="Protected">
RunningLoop: _RunningLoop
slotnames: Callable[..., TupleStr]
DATACLASS_FIELDS: dict[str, DataField]
MISSING_TYPE: Type[_MISSING_TYPE]
POST_INIT_NAME: str
CRLock = _CRLock
Alias = _alias
# </editor-fold>
# <editor-fold desc="Constants">
__all__: TupleStr
BUILTINS: DictStrAny
BUILTINS_CLASSES: TupleType
BUILTINS_FUNCTIONS: tuple[Union[BuiltinFunctionType, FunctionType], ...]
BUILTINS_OTHER: tuple[Any, ...]
console: Console
cp: console.print
DATACLASS_FIELDS: str
debug: Debug
fmic: IceCreamDebugger().format
fmicc: IceCreamDebugger().format
FRAME_SYS_INIT: FrameType
FUNCTION_MODULE: str
ic: IceCreamDebugger
icc: IceCreamDebugger
IgnoreAttr = Literal['asdict', 'attrs', 'defaults', 'keys', 'kwargs', 'kwargs_dict', 'public', 'values', 'values_dict']
IgnoreCopy = Union[CRLock, Environs, FrameType, GitConfigParser, GitSymbolicReference, Remote]
IgnoreStr = Union[GitConfigParser, GitRepo, ObjectId, PathLib]
LockClass = type(Lock())
NEWLINE: str
PICKLE_ATTRS: dict[Type, TupleStr]
POST_INIT_NAME: str
print_exception: console.print_exception
PYTHON_SYS: str
PYTHON_SITE: pathlib.Path
# </editor-fold>
# <editor-fold desc="NamedTuple">
Annotation = NamedTuple('Annotation', any=bool, args=list[Generic[_Annotation], ...], classvar=bool, cls=Type,
                        default=Any, final=bool, hint=Type, initvar=bool, literal=bool, name=str, optional=bool,
                        origin=Any, union=bool)
CacheWrapperInfo = NamedTuple('CacheWrapperInfo', hit=int, passed=int, total=int)
# </editor-fold>
# <editor-fold desc="Props">
class cprop(property):
    ALL: Pattern = ...
    PRIVATE: Pattern = ...
    PROTECTED: Pattern = ...
    PUBLIC: Pattern = ...
    _cache: dict
    cache: dict
    name: str
    key: str
    def __new__(cls, *args, **kwargs) -> cprop: ...
    def __init__(self) -> None: ...
    @functools.cache
    def _fget(self) -> Any: ...
    def _fset(self, value: Any) -> None: ...
    def _fdel(self) -> None: ...
class Key(Generic[_T]):
    d: Any
    f: Any
    m: bool
    __slots__: TupleStr
    def __init__(self, data: Any, default: Any = ...) -> None: ...
    def get(self, name: Any = ..., default: Any = ..., setvalue: bool = ...) -> Any: ...
    def set(self, name: Any = ..., value: Any = ...) -> Any: ...
    NAME: cprop
    _asdict: cprop
    name: cprop
    def __class_getitem__(cls, item: Any) -> GenericAlias: ...


# </editor-fold>
# <editor-fold desc="Enums">
class EnumBase(Enum, Generic[_T], _T):
    def _generate_next_value_(self: str, start: Any, count: Any, last_values: Any) -> str: ...
    @classmethod
    @functools.cache
    def asdict(cls) -> DictStrAny: ...
    @classmethod
    @functools.cache
    def attrs(cls) -> list: ...
    @classmethod
    @functools.cache
    def default(cls) -> Any: ...
    @classmethod
    @functools.cache
    def default_attr(cls) -> str: ...
    @classmethod
    @functools.cache
    def default_dict(cls) -> DictStrAny: ...
    @classmethod
    @functools.cache
    def default_value(cls) -> Any: ...
    @property
    @functools.cache
    def describe(self) -> tuple: ...
    @property
    @functools.cache
    def lower(self) -> str: ...
    @property
    @functools.cache
    def members(self) -> DictStrAny: ...
    @classmethod
    @functools.cache
    def values(cls) -> list: ...
class Access(EnumBase):
    ALL = ...
    PRIVATE = ...
    PROTECTED = ...
    PUBLIC = ...
    @classmethod
    @functools.cache
    def classify(cls, *args: str, **kwargs: Union[Enum, Any]) -> AccessEnumMembers: ...
    @functools.cache
    def es(self, name: str) -> bool: ...
    @functools.cache
    def include(self, name: str) -> Optional[bool]: ...
    @classmethod
    @functools.cache
    def type(cls, name: str) -> Optional[Access]: ...
class ChainRV(EnumBase):
    ALL = ...
    FIRST = ...
    UNIQUE = ...
class Executor(EnumBase):
    PROCESS = ...
    THREAD = ...
    NONE = ...
    async def run(self, func: Any, *args: Any, **kwargs: Any) -> Any: ...
class Kind(EnumBase):
    CLASS = ...
    DATA = ...
    METHOD = ...
    PROPERTY = ...
    STATIC = ...
class ModuleBase(EnumBase):
    @property
    @functools.cache
    def get(self): ...
    @property
    @functools.cache
    def load(self): ...
class Module(ModuleBase):
    FUNCTOOLS = ...
    TYPING = ...
class NBase(EnumBase):
    def _generate_next_value_(self: str, start: Any, count: Any, last_values: Any) -> str: ...
    def get(self, obj: Any, default: Any = ..., setvalue: bool = ...) -> Any: ...
    def getf(self, obj: Any, default: Any = ...) -> Any: ...
    @property
    @functools.cache
    def getter(self) -> attrgetter: ...
    def has(self, obj: Any) -> bool: ...
    def mro_first_data(self, obj: Any) -> Union[Any, NotImplemented]: ...
    def mro_first_dict(self, obj: Any) -> Union[Any, NotImplemented]: ...
    def mro_first_dict_no_object(self, obj: Any) -> Union[Any, NotImplemented]: ...
    def mro_values(self, obj: Any) -> TupleStr: ...
    def mro_values_default(self, obj: Any) -> tuple[Union[str, Type[Any]], ...]: ...
    def slot(self, obj: Any) -> bool: ...
    def slots_include(self, obj: Any) -> TupleStr: ...
class N(NBase):
    ALL = ...
    ANNOTATIONS = ...
    ARGS = ...
    ASDICT = ...
    BUILTINS = ...
    CACHE_CLEAR = ...
    CACHE_INFO = ...
    CACHED = ...
    CODE = ...
    CONTAINS = ...
    DATACLASS_FIELDS = ...
    DATACLASS_PARAMS = ...
    DELATTR = ...
    DICT = ...
    DIR = ...
    DOC = ...
    EQ = ...
    FILE = ...
    GET = ...
    GETATTRIBUTE = ...
    GETITEM = ...
    GETSTATE = ...
    HASH_EXCLUDE = ...
    IGNORE_ATTR = ...
    IGNORE_COPY = ...
    IGNORE_KWARG = ...
    IGNORE_STR = ...
    INIT = ...
    INIT_SUBCLASS = ...
    LEN = ...
    LOADER = ...
    MEMBERS = ...
    MODULE = ...
    MRO = ...
    NAME = ...
    PACKAGE = ...
    PICKLE = ...
    POST_INIT = ...
    QUALNAME = ...
    REDUCE = ...
    REDUCE_EX = ...
    REPR = ...
    REPR_EXCLUDE = ...
    REPR_NEWLINE = ...
    REPR_PPROPERTY = ...
    SETATTR = ...
    SETSTATE = ...
    SLOTS = ...
    SPEC = ...
    STR = ...
    SUBCLASSHOOK = ...
    _asdict = ...
    _cls = ...
    _copy = ...
    _count = ...
    _data = ...
    _extend = ...
    _external = ...
    _field_defaults = ...
    _fields = ...
    _file = ...
    _filename = ...
    _frame = ...
    _func = ...
    _function = ...
    _get = ...
    _globals = ...
    _id = ...
    _index = ...
    _ip = ...
    _item = ...
    _items = ...
    _key = ...
    _keys = ...
    _kind = ...
    _locals = ...
    _name = ...
    _node = ...
    _origin = ...
    _obj = ...
    _object = ...
    _path = ...
    _repo = ...
    _RV = ...
    _pypi = ...
    _remove = ...
    _reverse = ...
    _sort = ...
    _source = ...
    _update = ...
    _value = ...
    _values = ...
    _vars = ...
    add = ...
    append = ...
    asdict = ...
    cls = ...
    clear = ...
    co_name = ...
    code_context = ...
    copy = ...
    count = ...
    data = ...
    endswith = ...
    extend = ...
    external = ...
    f_back = ...
    f_code = ...
    f_globals = ...
    f_lineno = ...
    f_locals = ...
    file = ...
    filename = ...
    frame = ...
    func = ...
    function = ...
    get_ = ...
    globals = ...
    id = ...
    index = ...
    ip = ...
    item = ...
    items = ...
    key = ...
    keys = ...
    kind = ...
    lineno = ...
    locals = ...
    name = ...
    node = ...
    origin = ...
    obj = ...
    object = ...
    path = ...
    repo = ...
    rv = ...
    pop = ...
    popitem = ...
    pypi = ...
    remove = ...
    reverse = ...
    self_ = ...  # To avoid conflict with Enum
    sort = ...
    source = ...
    startswith = ...
    tb_frame = ...
    tb_lineno = ...
    tb_next = ...
    update = ...
    value = ...
    values = ...
    vars = ...
# </editor-fold>
# <editor-fold desc="Enums - NamedTuple & Typing">
_AccessEnumMember = Union[dict[str, Union[Enum, Any]], list[str]]
AccessEnumMembers = NamedTuple('AccessEnumMembers', all=_AccessEnumMember, private=_AccessEnumMember,
                               protected=_AccessEnumMember, public=_AccessEnumMember)
EnumBaseAlias: Alias

# </editor-fold>
# <editor-fold desc="Functions">
def aioloop() -> Optional[RunningLoop]: ...
def allin(origin: Iterable, destination: Iterable) -> bool: ...
def annotations(obj: Any, stack: Union[FrameType, int] = ...,
                sequence: bool = ...) -> Union[dict[str, Annotation], dict]: ...
def annotations_init(cls: Type[Union[NamedAnnotationsType, NamedTuple]], stack: Union[FrameType, int] = ...,
                     optional: bool = ..., **kwargs) -> NamedTuple: ...
def anyin(origin: Iterable, destination: Iterable) -> Optional[Any]: ...
class _cache_wrapper(Generic[_T]):
    __wrapped__: Callable[..., _T]
    cache_hit: int = ...
    cache_passed: int = ...
    cache_total: int = ...
    def __call__(self, *args: Any, **kwargs: Any) -> _T: ...
    def cache_clear(self) -> None: ...
    def cache_info(self) -> CacheWrapperInfo: ...
class cache:
    enabled: bool = ...
    memo: dict[Callable, dict[bytes, Any]] = ...
    def __call__(self, *args: Any, **kwargs: Any) -> _T: ...
    @staticmethod
    def cache_clear() -> None: ...
    @staticmethod
    def cache_info() -> CacheWrapperInfo: ...
    @staticmethod
    def wrapper(*args: Any, **kwargs: Any) -> _cache_wrapper: ...
def cmd(command: Iterable,
        exc: bool = ...,
        lines: bool = ...,
        shell: bool = ...,
        py: bool = ...,
        pysite: bool = ...) -> Union[CompletedProcess, int, list, str]: ...
def cmdname(func: Callable, sep: str = ...) -> str: ...
def current_task_name() -> str: ...
@singledispatch
def delete(data: Union[MutableMapping, list], key: Iterable = ...) -> Optional[dict]: ...
@delete.register
def delete_list(data: list, key: Iterable = ...) -> Optional[list]: ...
def dict_sort(data: dict, ordered: bool = ..., reverse: bool = ...) -> Union[dict, OrderedDict]:...
def effect(apply: Callable, data: Iterable) -> NoReturn:...
def enumvalue(data: Any) -> Any:...
def get(data: Any, *args: Any, default: Any = ..., names: bool = ..., one: bool = ..., recursive: bool = ...,
        setvalue: bool = ...) -> Union[defaultdict[str, list], DictStrAny, list, Any]:...
@overload
@functools.cache
def getnostr(data: str, attr: Optional[str] = ...) -> str:...
@overload
@functools.cache
def getnostr(data: Any, attr: Optional[str] = ...) -> str:...
def getset(data: Any, name: str, default: Any = ..., setvalue: bool = ...) -> Any: ...
def iseven(number: int) -> bool: ...
def in_dict(data: MutableMapping, items: Optional[dict] = ..., **kwargs: Any) -> bool: ...
def join_newline(data: Iterable[str]) -> str: ...
def map_reduce_even(iterable: Iterable[_T]) -> list[_U, list[_T]]:...
def map_with_args(data: Any, func: Callable, /, *args, pred: Callable = lambda x: True if x else False,
                  split: str = ' ', **kwargs) -> list: ...
def newprop(name: str = ..., default: Optional[Any, Callable, partial] = ...,
            pprop: bool = ...) -> Union[property, pproperty]: ...
def noexception(
        func: Callable[..., _T],
        *args,
        default_: Any = ...,
        exc_: ExceptionUnion = ...,
        **kwargs: Any
) -> _T: ...
def prefixed(name: str) -> str: ...
def repr_format(obj: Any, attrs: Iterable[str], clear: bool = ..., newline: bool = ...) -> str: ...
@decorator
def runwarning(func: Callable, *args: Any, **kwargs: Any) -> Any: ...
def split_sep(sep: str = ...) -> dict: ...
def startswith(name: str, builtin: bool = ...) -> bool: ...
def to_camel(text: str, replace: bool = True) -> str: ...
def to_iter(data: Any, split: str = ...) -> Union[Sized, MutableMapping, Sequence, MutableSequence]: ...
def to_vars(): ...
def token_open(file: Union[PathLike, PathLib, str]) -> str: ...
def varname(index: int = ..., lower: bool = ..., sep: str = ...) -> Optional[str]: ...
def yield_if(data: Any, pred: Callable = ..., split: str = ...,
             apply: Union[Callable, tuple[Callable, ...]] = ...) -> Generator: ...
def yield_last(data: Any) -> Iterator[tuple[bool, Any, Optional[Any, None]]]: ...
# </editor-fold>
# <editor-fold desc="Es">
class Es(Generic[_T]):
    Source = NamedTuple('Source', code=str, code_line=tuple[str, int], complete=str, complete_line=tuple[str, int],
                        context=TupleStr)
    FrameBase = NamedTuple('FrameBase', back=FrameType, code=CodeType,
                       frame=FrameType, function=str,
                       globals=DictStrAny, lineno=int, locals=DictStrAny, name=str,
                       package=str, path=PathLib,
                       source=Source, vars=DictStrAny)
    __slots__: TupleStr = ...
    data: Union[_T, FrameInfo, FrameType, TracebackType, Any] = ...
    def __init__(self, data: Any = ...) -> None: ...
    def __call__(self, *args: Type) -> Bool: ...
    def __getstate__(self) -> DictStrAny: ...
    def __hash__(self) -> int: ...
    def __reduce__(self) -> Tuple[Type[Es], Tuple]: ...
    def __reduce_ex__(self, protocol: int) -> Tuple[Type[Es], Tuple]: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: DictStrAny): ...
    def __str__(self) -> str: ...
    # <editor-fold desc="Es - Frame">
    class Frame(FrameBase):
        __slots__: TupleStr = ...
        def __new__(cls, *args: Str, **kwargs: Any) -> Es.Frame: ...
    # </editor-fold>
    # <editor-fold desc="Es - Protected">
    @property
    @functools.cache
    def _func(self) -> Any: ...
    @property
    @functools.cache
    def _function(self) -> str: ...
    # </editor-fold>
    # <editor-fold desc="Es - Bool">
    @property
    @functools.cache
    def annotation(self) -> Bool: ...
    @property
    @functools.cache
    def annotationstype(self) -> Bool: ...
    @property
    @functools.cache
    def annotationstype_both(self) -> Bool: ...
    @property
    @functools.cache
    def annotationstype_sub(self) -> Bool: ...
    @property
    @functools.cache
    def asdict(self) -> DictStrAny: ...
    @property
    @functools.cache
    def asdictmethod(self) -> Bool: ...
    @property
    @functools.cache
    def asdictmethod_sub(self) -> Bool: ...
    @property
    @functools.cache
    def asdictproperty(self) -> Bool: ...
    @property
    @functools.cache
    def asdictproperty_sub(self) -> Bool: ...
    @property
    @functools.cache
    def ast(self) -> Bool: ...
    @property
    @functools.cache
    def asyncfor(self) -> Bool: ...
    @property
    @functools.cache
    def asyncfunctiondef(self) -> Bool: ...
    @property
    @functools.cache
    def asyncgen(self) -> Bool: ...
    @property
    @functools.cache
    def asyncgenfunction(self) -> Bool: ...
    @property
    @functools.cache
    def asyncwith(self) -> Bool: ...
    @property
    @functools.cache
    def attribute(self) -> Bool: ...
    @property
    @functools.cache
    def await_ast(self) -> Bool: ...
    @property
    @functools.cache
    def awaitable(self) -> Bool: ...
    @property
    @functools.cache
    def basestate(self) -> Bool: ...
    @property
    @functools.cache
    def bool(self) -> Bool: ...
    @property
    @functools.cache
    def builtin(self) -> Bool: ...
    @property
    @functools.cache
    def builtinclass(self) -> Bool: ...
    @property
    @functools.cache
    def builtinfunction(self) -> Bool: ...
    @property
    @functools.cache
    def builtinfunctiontype(self) -> Bool: ...
    @property
    @functools.cache
    def bytesio(self) -> Bool: ...
    @property
    @functools.cache
    def cache(self) -> Bool: ...
    @property
    @functools.cache
    def cached_property(self) -> Bool: ...
    @property
    @functools.cache
    def callable(self) -> Bool: ...
    @property
    @functools.cache
    def chain(self) -> Bool: ...
    @property
    @functools.cache
    def chainmap(self) -> Bool: ...
    @property
    @functools.cache
    def classdef(self) -> Bool: ...
    @property
    @functools.cache
    def classmethoddescriptortype(self) -> Bool: ...
    @property
    @functools.cache
    def classvar(self) -> Bool: ...
    @property
    @functools.cache
    def clsmethod(self) -> Bool: ...
    @property
    @functools.cache
    def codetype(self) -> Bool: ...
    @property
    @functools.cache
    def collections(self) -> Bool: ...
    @property
    @functools.cache
    def container(self) -> Bool: ...
    @property
    @functools.cache
    def coro(self) -> Bool: ...
    @property
    @functools.cache
    def coroutine(self) -> Bool: ...
    @property
    @functools.cache
    def coroutinefunction(self) -> Bool: ...
    @property
    @functools.cache
    def default_factory(self) -> Bool: ...
    @property
    @functools.cache
    def datafield(self) -> Bool: ...
    @property
    @functools.cache
    def datatype(self) -> Bool: ...
    @property
    @functools.cache
    def datatype_both(self) -> Bool: ...
    @property
    @functools.cache
    def datatype_sub(self) -> Bool: ...
    @property
    @functools.cache
    def defaultdict(self) -> Bool: ...
    @property
    @functools.cache
    def deleter(self) -> Bool: ...
    @property
    @functools.cache
    def dict(self) -> Bool: ...
    @property
    @functools.cache
    def dicttype(self) -> Bool: ...
    @property
    @functools.cache
    def dicttype_sub(self) -> Bool: ...
    @property
    @functools.cache
    def dynamicclassattribute(self) -> Bool: ...
    @property
    @functools.cache
    def dlst(self) -> Bool: ...
    @property
    @functools.cache
    def enum(self) -> Bool: ...
    @property
    @functools.cache
    def enum_sub(self) -> Bool: ...
    @property
    @functools.cache
    def enumbase(self) -> Bool: ...
    @property
    @functools.cache
    def enumbase_sub(self) -> Bool: ...
    @property
    @functools.cache
    def even(self) -> Bool: ...
    @property
    @functools.cache
    def fileio(self) -> Bool: ...
    @property
    @functools.cache
    def float(self) -> Bool: ...
    @property
    @functools.cache
    def frameinfo(self) -> Bool: ...
    @property
    @functools.cache
    def frametype(self) -> Bool: ...
    @property
    @functools.cache
    def functiondef(self) -> Bool: ...
    @property
    @functools.cache
    def functiontype(self) -> Bool: ...
    @property
    @functools.cache
    def generator(self) -> Bool: ...
    @property
    @functools.cache
    def generatortype(self) -> Bool: ...
    @property
    @functools.cache
    def genericalias(self) -> Bool: ...
    @property
    @functools.cache
    def getattrnobuiltintype(self) -> Bool: ...
    @property
    @functools.cache
    def getattrnobuiltintype_sub(self) -> Bool: ...
    @property
    @functools.cache
    def getattrtype(self) -> Bool: ...
    @property
    @functools.cache
    def getattrtype_sub(self) -> Bool: ...
    def getsetdescriptor(self, n: Any = None) -> Bool: ...
    @property
    @functools.cache
    def getsetdescriptortype(self) -> Bool: ...
    @property
    @functools.cache
    def gettype(self) -> Bool: ...
    @property
    @functools.cache
    def gettype_sub(self) -> Bool: ...
    @functools.cache
    def has(self, name: Any) -> Bool: ...
    @property
    @functools.cache
    def hashable(self) -> Bool: ...
    @property
    @functools.cache
    def import_ast(self) -> Bool: ...
    @property
    @functools.cache
    def importfrom(self) -> Bool: ...
    @property
    @functools.cache
    def initvar(self) -> Bool: ...
    @property
    @functools.cache
    def installed(self) -> Bool: ...
    @functools.cache
    def instance(self, *args: Type) -> Bool: ...
    @property
    @functools.cache
    def int(self) -> Bool: ...
    @property
    @functools.cache
    def io(self) -> Bool: ...
    @property
    @functools.cache
    def iterable(self) -> Bool: ...
    @property
    @functools.cache
    def iterator(self) -> Bool: ...
    @property
    @functools.cache
    def lambdatype(self) -> Bool: ...
    @property
    @functools.cache
    def list(self) -> Bool: ...
    @property
    @functools.cache
    def lst(self) -> Bool: ...
    @property
    @functools.cache
    def mappingproxytype(self) -> Bool: ...
    @property
    @functools.cache
    def mappingproxytype_sub(self) -> Bool: ...
    @property
    @functools.cache
    def memberdescriptor(self) -> Bool: ...
    @property
    @functools.cache
    def memberdescriptortype(self) -> Bool: ...
    @property
    @functools.cache
    def meta(self) -> Bool: ...
    @property
    @functools.cache
    def meta_sub(self) -> Bool: ...
    @property
    @functools.cache
    def metatype(self) -> Bool: ...
    @property
    @functools.cache
    def metatype_sub(self) -> Bool: ...
    @property
    @functools.cache
    def method(self) -> Bool: ...
    @property
    @functools.cache
    def methoddescriptor(self) -> Bool: ...
    @property
    @functools.cache
    def methoddescriptortype(self) -> Bool: ...
    @property
    @functools.cache
    def methodtype(self) -> Bool: ...
    @property
    @functools.cache
    def methodwrappertype(self) -> Bool: ...
    @property
    @functools.cache
    def methodwrappertype_sub(self) -> Bool: ...
    @property
    @functools.cache
    def missing(self) -> Bool: ...
    @property
    @functools.cache
    def mlst(self) -> Bool: ...
    @property
    @functools.cache
    def mm(self) -> Bool: ...
    @property
    @functools.cache
    def moduletype(self) -> Bool: ...
    @property
    @functools.cache
    def module_function(self) -> Bool: ...
    @property
    @functools.cache
    def noncomplex(self) -> Bool: ...
    @property
    @functools.cache
    def namedtype(self) -> Bool: ...
    @property
    @functools.cache
    def namedtype_sub(self) -> Bool: ...
    @property
    @functools.cache
    def named_annotationstype(self) -> Bool: ...
    @property
    @functools.cache
    def named_annotationstype_sub(self) -> Bool: ...
    @property
    @functools.cache
    def none(self) -> Bool: ...
    @property
    @functools.cache
    def object(self) -> Bool: ...
    @property
    @functools.cache
    def pathlib(self) -> Bool: ...
    @property
    @functools.cache
    def picklable(self) -> Bool: ...
    @property
    @functools.cache
    def primitive(self) -> Bool: ...
    @property
    @functools.cache
    def pproperty(self) -> Bool: ...
    @property
    @functools.cache
    def prop(self) -> Bool: ...
    @property
    @functools.cache
    def property_any(self) -> Bool: ...
    @functools.cache
    def readonly(self, name: Union[N, str] = ...) -> Union[Bool, Exception]: ...
    @property
    @functools.cache
    def reducible(self) -> Bool: ...
    @property
    @functools.cache
    def reducible_sequence_subclass(self) -> Bool: ...
    @property
    @functools.cache
    def routine(self) -> Bool: ...
    @property
    @functools.cache
    def sequence(self) -> Bool: ...
    @property
    @functools.cache
    def sequence_sub(self) -> Bool: ...
    @property
    @functools.cache
    def setter(self) -> Bool: ...
    @property
    @functools.cache
    def settype(self) -> Bool: ...
    @property
    @functools.cache
    def simple(self) -> Bool: ...
    @property
    @functools.cache
    def sized(self) -> Bool: ...
    @property
    @functools.cache
    def slist(self) -> Bool: ...
    @functools.cache
    def slot(self, name: Union[N, Str]) -> Bool: ...
    @property
    @functools.cache
    def slotstype(self) -> Bool: ...
    @property
    @functools.cache
    def slotstype_sub(self) -> Bool: ...
    @property
    @functools.cache
    def static(self) -> Bool: ...
    @property
    @functools.cache
    def str(self) -> Bool: ...
    @property
    @functools.cache
    def stuple(self) -> Bool: ...
    @functools.cache
    def subclass(self, *args: Type) -> Bool: ...
    @property
    @functools.cache
    def stringio(self) -> Bool: ...
    @property
    @functools.cache
    def tracebacktype(self) -> Bool: ...
    @property
    @functools.cache
    def tuple(self) -> Bool: ...
    @property
    @functools.cache
    def type(self) -> Bool: ...
    @property
    @functools.cache
    def unicode(self) -> Bool: ...
    @property
    @functools.cache
    def wrapperdescriptortype(self) -> Bool: ...
    @functools.cache
    def writeable(self, name: Union[N, Str]) -> Bool: ...
    # </editor-fold>
    # <editor-fold desc="Es - Inspect">
    @functools.cache
    def annotations(self, stack: Union[FrameType, int] = ...) -> Dict[str, Annotation]: ...
    @functools.cache
    def attributes(self, stack: Union[FrameType, int] = ...) -> Dict[str, Attribute]: ...
    @property
    @functools.cache
    def cls(self) -> Type: ...
    @property
    @functools.cache
    def clsname(self) -> str: ...
    @property
    @functools.cache
    def clsqual(self) -> str: ...
    @property
    @functools.cache
    def es_cls(self) -> Es[Type]: ...
    @property
    @functools.cache
    def fields(self) -> Dict[str, DataField]: ...
    @property
    @functools.cache
    def first_builtin(self) -> Type: ...
    @property
    @functools.cache
    def importable_name_cls(self) -> Optional[str]: ...
    @property
    @functools.cache
    def importable_name_data(self) -> Optional[str]: ...
    @property
    @functools.cache
    def modname(self) -> Optional[str]: ...
    @property
    @functools.cache
    def mro(self) -> Tuple[Type[Any, DataType], ...]: ...
    @property
    @functools.cache
    def mro_and_data(self) -> Tuple[Type[Any, _T], ...]: ...
    @functools.cache
    def mro_first_data(self, name: Union[N, Str]) -> Union[Any, NotImplemented]: ...
    @functools.cache
    def mro_first_dict(self, name: Union[N, Str],
                       mro: Tuple[Type[Any, DataType], ...]) -> Union[Any, NotImplemented]: ...
    @functools.cache
    def mro_first_dict_no_object(self, name: Union[N, Str]) -> Union[Any, NotImplemented]: ...
    @functools.cache
    def mro_values(self, name: Union[N, Str]) -> TupleStr: ...
    @functools.cache
    def mro_values_default(self, name: Union[N, Str]) -> Tuple[Union[str, Type[Any]], ...]: ...
    @property
    @functools.cache
    def name(self) -> Optional[str]: ...
    @classmethod
    @functools.cache
    def prop_getter(cls, prop: property) -> Union[attrgetter, NotImplemented]: ...
    @property
    @functools.cache
    def slots(self) -> TupleStr: ...
    @functools.cache
    def slots_include(self, name: Union[N, Str]) -> TupleStr: ...
    @property
    @functools.cache
    def super(self) -> Type: ...
    # </editor-fold>
    # <editor-fold desc="Es - Utils">
    @property
    @functools.cache
    def deepcopy(self) -> Any: ...
    @property
    @functools.cache
    def frame(self) -> Optional[Es.Frame]: ...
    @functools.cache
    def get(self, name: None = ...) -> Optional[Es.Frame]: ...
    @overload
    @functools.cache
    def get(self, name: Any, default: Any = ..., setvalue: bool = ...) -> Any: ...
    @overload
    @functools.cache
    def getf(self, name: None = ...) -> Optional[Es.Frame]: ...
    @overload
    @functools.cache
    def getf(self, name: Union[Enum, Str, Any] = ..., default: Any = ...) -> Any: ...
    @overload
    @functools.cache
    def getfinfo(self, name: None = ...) -> Optional[Es.Frame]: ...
    @overload
    @functools.cache
    def getfinfo(self, name: Union[Enum, Str, Any] = ..., default: Any = ...) -> Any: ...
    @overload
    @functools.cache
    def getftype(self, name: None = ...) -> Optional[Es.Frame]: ...
    @overload
    @functools.cache
    def getftype(self, name: Union[Enum, Str, Any] = ..., default: Any = ...) -> Any: ...
    @overload
    @functools.cache
    def getftrace(self, name: None = ...) -> Es.Frame: ...
    @overload
    @functools.cache
    def getftrace(self, name: Union[Enum, Str, Any] = ..., default: Any = ...) -> Any: ...
    @functools.cache
    def node(self, complete: bool = ..., line: bool = ...) -> Union[Tuple[AST, int], AST]: ...
    @property
    @functools.cache
    def path(self) -> PathLib: ...
    @property
    @functools.cache
    def pickles(self) -> Optional[bytes]: ...
    def set(self, name: Any, value: Any = ...) -> Any: ...
    @functools.cache
    def _source(self, complete: bool = ..., line: bool = ...) -> Union[Tuple[str, int], str]: ...
    @functools.cache
    def _source_open(self, line: bool = ...) -> Optional[Union[Tuple[str, int], str]]: ...
    @property
    @functools.cache
    def source(self) -> Source: ...
    def state(self, data: DictStrAny = ...) -> Union[DictStrAny, Any]: ...
    @property
    @functools.cache
    def state_methods(self) -> Any: ...
    @property
    @functools.cache
    def unpickles(self) -> Any: ...
    # </editor-fold>
    def __class_getitem__(cls, item: Any) -> GenericAlias: ...
Attribute = NamedTuple('Attribute', annotation=Annotation, default=Union[Any, NotImplemented], defining=type, es=Es,
                       field=Es[DataField], kind=Kind, name=str, object=Any, qual=str)
# </editor-fold>
# <editor-fold desc="Exceptions">
class CmdError(Exception):
    def __init__(self, rv: CompletedProcess) -> None: ...
class CmdAioError(CmdError):
    def __init__(self, rv: CompletedProcess) -> None: ...
# </editor-fold>
# <editor-fold desc="Types">
class AnnotationsType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class AsDictMethodType(metaclass=ABCMeta):
    @abstractmethod
    def asdict(self, *args: Any, **kwargs: Any) -> DictStrAny: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class AsDictPropertyType(metaclass=ABCMeta):
    @property
    @abstractmethod
    def asdict(self) -> DictStrAny: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class DataType(metaclass=ABCMeta):
    __annotations__: MappingProxyType
    __dataclass_fields__: dict[str, DataField]
    def __repr__(self) -> str: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class DictType(metaclass=ABCMeta):
    __dict__: MappingProxyType
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class GetAttrNoBuiltinType(metaclass=ABCMeta):
    def __getattribute__(self, name: str) -> Any: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class GetAttrType(metaclass=ABCMeta):
    def __getattribute__(self, name: str) -> Any: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
@runtime_checkable
class GetItemSupportType(Protocol):
    __slots__: TupleStr = ...
    @overload
    @abstractmethod
    def __getitem__(self, i: int) -> _T_co: ...
    @overload
    @abstractmethod
    def __getitem__(self, s: slice) -> Sequence[_T_co]: ...
@runtime_checkable
class GetSupportType(Protocol):
    __slots__: TupleStr = ...
    @abstractmethod
    def get(self, name: str, default: Any = ...) -> Any: ...
@runtime_checkable
class GetType(Protocol):
    def get(self, name: str, default: Any = ...) -> Any:
        pass
class NamedType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    def _asdict(self) -> DictStrAny: ...
    _fields: TupleStr
    _field_defaults: DictStrAny
class NamedAnnotationsType(metaclass=ABCMeta):
    __annotations__: MappingProxyType
    _fields: TupleStr
    _field_defaults: MappingProxyType
    def _asdict(self) -> DictStrAny: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class SlotsType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
# </editor-fold>
# <editor-fold desc="Classes">
class BoxKeys(Box[str, Any]):
    def __init__(self, keys: Iterable,
                 value: Optional[Union[Type, Literal['lower']]] = ...) -> None: ...
class Chain(ChainMap):
    rv: ChainRV
    default: Any
    maps: list[Union[Iterable, NamedType, MutableMapping]]
    def __init__(self, *maps: ..., rv: ChainRV = ..., default: Any = ...) -> None: ...
    def __getitem__(self, key: str) -> Any: ...
    def __delitem__(self, key: str) -> None: ...
    def delete(self, key: str) -> None: ...
    def __setitem__(self, key: str, value: Any) -> None: ...
    def set(self, key: str, value: Any) -> None: ...
class pproperty(property):
    def __init__(self, fget: Callable = ..., fset: Callable = ..., fdel: Callable = ..., doc: str = ...) -> None: ...
# </editor-fold>
# <editor-fold desc="Bases">
class BaseState:
    __pickle__: TupleStr = ...
    __slots__: TupleStr = ...
    def __getstate__(self): ...
    def __setstate__(self, state): ...
# </editor-fold>
# <editor-fold desc="States">
class StateEnv(Environs, BaseState):
    def __init__(self, *, eager: bool = ..., expand_vars: bool = ...): ...
# </editor-fold>
# <editor-fold desc="Echo">
def black(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def blue(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def cyan(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def green(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def magenta(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
            blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def red(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
        blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def white(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def yellow(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bblack(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bblue(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bcyan(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bgreen(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bmagenta(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
             blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bred(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bwhite(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def byellow(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
            blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
# </editor-fold>
# <editor-fold desc="Test">
class TestAsync:
    _async_classmethod: str = ...
    _classmethod: str = ...
    _async_method: str = ...
    _method: str = ...
    _cprop: str = ...
    _async_pprop: str = ...
    _pprop: str = ...
    _async_prop: str = ...
    _prop: str = ...
    _async_staticmethod: str = ...
    _staticmethod: str = ...
    @classmethod
    async def async_classmethod(cls) -> str: ...
    @classmethod
    def classmethod(cls) -> str: ...
    async def async_method(self) -> str: ...
    def method(self) -> str: ...
    @property
    def cprop(self) -> str: ...
    @property
    async def async_pprop(self) -> str: ...
    @property
    def pprop(self) -> str: ...
    @property
    async def async_prop(self) -> str: ...
    @property
    def prop(self) -> str: ...
    @staticmethod
    async def async_staticmethod() -> str: ...
    @staticmethod
    def staticmethod() -> str: ...
@dataclass
class TestData:
    dataclass_classvar: ClassVar[str] = ...
    dataclass_default: str = ...
    dataclass_default_factory: Union[dict, str] = ...
    dataclass_default_factory_init: Union[dict, str] = ...
    dataclass_default_init: str = ...
    dataclass_initvar: InitVar[str] = ...
    dataclass_str: str = ...
    def __post_init__(self, dataclass_initvar: str) -> None: ...
    def __class_getitem__(cls, item: Any) -> GenericAlias: ...
class TestDataDictMix(TestData):
    subclass_annotated_str: str = ...
    subclass_classvar: ClassVar[str] = ...
    subclass_str: str = ...
    def __init__(self, dataclass_initvar: str = ..., subclass_dynamic: str = ...,) -> None: ...
class TestDataDictSlotMix(TestDataDictMix):
    __slots__ = ('_slot_property', 'slot', )
    _slot_property: str
    slot: str
    def __init__(self, dataclass_initvar: str =  ..., slot_property: str =  ..., slot: str =  ...) -> None: ...
    @pproperty
    def slot_property(self) -> str: ...
# </editor-fold>
