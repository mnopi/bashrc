# <editor-fold desc="Imports">
import ast as ast
import collections.abc as abc
import copy as copy
import functools as functools
# noinspection PyCompatibility
import grp as grp
import os as os
import pathlib as pathlib
# noinspection PyCompatibility
import pwd as pwd
import re as re
import subprocess as subprocess
import sys as sys
import textwrap as textwrap
import tokenize as tokenize
import types as types
import warnings as warnings
from _typeshed import SupportsKeysAndGetItem
from abc import ABCMeta as ABCMeta
from abc import abstractmethod as abstractmethod
from ast import AST as AST
from ast import AsyncFor as AsyncFor
from ast import AsyncFunctionDef as AsyncFunctionDef
from ast import AsyncWith as AsyncWith
from ast import Await as Await
from ast import ClassDef as ClassDef
from ast import FunctionDef as FunctionDef
from ast import get_source_segment as get_source_segment
from ast import Import as Import
from ast import ImportFrom as ImportFrom
from ast import NodeVisitor as NodeVisitor
from ast import walk as walk
from asyncio import all_tasks as all_tasks
from asyncio import as_completed as as_completed
from asyncio import BaseEventLoop as BaseEventLoop
from asyncio import CancelledError as CancelledError
from asyncio import Condition as Condition
from asyncio import create_subprocess_exec as create_subprocess_exec
from asyncio import create_subprocess_shell as create_subprocess_shell
from asyncio import create_task as create_task
from asyncio import current_task as current_task
from asyncio import ensure_future as ensure_future
from asyncio import Event as Event
from asyncio import gather as gather
from asyncio import get_event_loop as get_event_loop
from asyncio import get_running_loop as get_running_loop
from asyncio import Future as Future
from asyncio import iscoroutine as iscoroutine
from asyncio import isfuture as isfuture
from asyncio import Lock as AsyncLock
from asyncio import Queue as AsyncQueue
from asyncio import QueueEmpty as QueueEmpty
from asyncio import QueueFull as QueueFull
from asyncio import run as asyncrun
from asyncio import run_coroutine_threadsafe as run_coroutine_threadsafe
from asyncio import Semaphore as Semaphore
from asyncio import sleep as sleep
from asyncio import Task as AsyncTask
from asyncio import to_thread as to_thread
from asyncio.events import _RunningLoop
from collections import ChainMap as ChainMap
from collections import defaultdict as defaultdict
from collections import namedtuple as namedtuple
from collections import OrderedDict as OrderedDict
from collections.abc import AsyncGenerator as AsyncGenerator
from collections.abc import AsyncIterable as AsyncIterable
from collections.abc import AsyncIterator as AsyncIterator
from collections.abc import Awaitable as Awaitable
from collections.abc import ByteString as ByteString
from collections.abc import Callable as Callable
from collections.abc import Collection as Collection
from collections.abc import Container as Container
from collections.abc import Coroutine as Coroutine
from collections.abc import Generator as Generator
from collections.abc import Hashable as Hashable
from collections.abc import ItemsView as ItemsView
from collections.abc import Iterable as Iterable
from collections.abc import Iterator as Iterator
from collections.abc import KeysView as KeysView
from collections.abc import Mapping as Mapping
from collections.abc import MappingView as MappingView
from collections.abc import MutableMapping as MutableMapping
from collections.abc import MutableSequence as MutableSequence
from collections.abc import MutableSet as MutableSet
from collections.abc import Reversible as Reversible
from collections.abc import Sequence as Sequence
from collections.abc import Set as Set
from collections.abc import Sized as Sized
from collections.abc import ValuesView as ValuesView
from concurrent.futures.process import ProcessPoolExecutor as ProcessPoolExecutor
from concurrent.futures.thread import ThreadPoolExecutor as ThreadPoolExecutor
from contextlib import contextmanager as contextmanager
from contextlib import suppress as suppress
from dataclasses import _MISSING_TYPE
from dataclasses import dataclass as dataclass
from dataclasses import Field as DataField
from dataclasses import field as datafield
from dataclasses import fields as datafields
from dataclasses import InitVar as InitVar
from enum import auto as auto
from enum import Enum as Enum
from enum import EnumMeta as EnumMeta
from functools import cached_property as cached_property
from functools import partial as partial
from functools import singledispatch as singledispatch
from functools import singledispatchmethod as singledispatchmethod
from functools import total_ordering as total_ordering
from functools import wraps as wraps
from importlib import import_module as import_module
from importlib.util import module_from_spec as module_from_spec
from importlib.util import spec_from_file_location as spec_from_file_location
from inspect import classify_class_attrs as classify_class_attrs
from inspect import FrameInfo as FrameInfo
from inspect import getfile as getfile
from inspect import getsource as getsource
from inspect import getsourcefile as getsourcefile
from inspect import getsourcelines as getsourcelines
from inspect import isasyncgenfunction as isasyncgenfunction
from inspect import isawaitable as isawaitable
from inspect import iscoroutinefunction as iscoroutinefunction
from inspect import isgetsetdescriptor as isgetsetdescriptor
from inspect import ismemberdescriptor as ismemberdescriptor
from inspect import ismethoddescriptor as ismethoddescriptor
from inspect import isroutine as isroutine
from inspect import stack as insstack
from io import BytesIO as BytesIO
from io import FileIO as FileIO
from io import StringIO as StringIO
from logging import addLevelName as addLevelName
from logging import basicConfig as basicConfig
from logging import CRITICAL as CRITICAL
from logging import DEBUG as DEBUG
from logging import ERROR as ERROR
from logging import FileHandler as FileHandler
from logging import Formatter as Formatter
from logging import getLevelName as getLevelName
from logging import getLogger as getLogger
from logging import getLoggerClass as getLoggerClass
from logging import Handler as Handler
from logging import INFO as INFO
from logging import Logger as Logger
from logging import LoggerAdapter as LoggerAdapter
from logging import NOTSET as NOTSET
from logging import setLoggerClass as setLoggerClass
from logging import StreamHandler as StreamHandler
from logging import WARNING as WARNING
from logging.handlers import RotatingFileHandler as RotatingFileHandler
from operator import attrgetter as attrgetter
from os import chdir as chdir
from os import environ as environ
from os import getenv as getenv
from os import PathLike as PathLike
from os import system as system
from pathlib import Path as PathLib
from pickle import dump as pickle_dump
from pickle import dumps as pickle_dumps
from pickle import load as pickle_load
from pickle import loads as pickle_loads
from pickle import PicklingError as PicklingError
from subprocess import CompletedProcess as CompletedProcess
from shlex import quote as shquote
from shlex import split as shsplit
from shutil import rmtree as rmtree
from site import getsitepackages as getsitepackages
from site import USER_SITE as USER_SITE
from subprocess import CompletedProcess as CompletedProcess
from subprocess import run as subrun
from tempfile import TemporaryDirectory as TemporaryDirectory
from threading import _CRLock
from threading import Lock as Lock
from timeit import timeit as timeit
from types import AsyncGeneratorType as AsyncGeneratorType
from types import BuiltinFunctionType as BuiltinFunctionType
from types import ClassMethodDescriptorType as ClassMethodDescriptorType
from types import CodeType as CodeType
from types import CoroutineType as CoroutineType
from types import DynamicClassAttribute as DynamicClassAttribute
from types import FrameType as FrameType
from types import FunctionType as FunctionType
from types import GeneratorType as GeneratorType
from types import GenericAlias as GenericAlias
from types import GetSetDescriptorType as GetSetDescriptorType
from types import LambdaType as LambdaType
from types import MappingProxyType as MappingProxyType
from types import MemberDescriptorType as MemberDescriptorType
from types import MethodType as MethodType
from types import MethodWrapperType as MethodWrapperType
from types import ModuleType as ModuleType
from types import SimpleNamespace as Simple
from types import TracebackType as TracebackType
from types import WrapperDescriptorType as WrapperDescriptorType
from typing import _alias
from typing import Any
from typing import AnyStr
from typing import ByteString
from typing import Callable
from typing import ChainMap
from typing import ClassVar
from typing import Generator
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import KeysView
from typing import Literal
from typing import MutableMapping
from typing import MutableSequence
from typing import MutableSet
from typing import NamedTuple
from typing import NoReturn
from typing import Optional
from typing import OrderedDict
from typing import overload
from typing import Protocol
from typing import runtime_checkable
from typing import Sequence
from typing import Sized
from typing import Type
from typing import TypeVar
from typing import Union
from typing import ValuesView
from warnings import catch_warnings as catch_warnings
from warnings import filterwarnings as filterwarnings

import colorama as colorama
import executing as executing
import jsonpickle.ext.numpy as pickle_np
import numpy as np
import pandas as pd
import paramiko as paramiko
from astpretty import pprint as astprint
from astpretty import pformat as astformat
from asttokens import ASTTokens as ASTTokens
from box import Box as Box
from bson import ObjectId as ObjectId
from click import secho as secho
from click.exceptions import Exit as Exit
from colorlog import ColoredFormatter as ColoredFormatter
from colorlog import LevelFormatter as LevelFormatter
from decorator import decorator as decorator
from devtools import Debug as Debug
from dpath.util import delete as dpathdelete
from dpath.util import get as dpathget
from dpath.util import new as dpathnew
from dpath.util import set as dpathset
from dpath.util import search as dpathsearch
from dpath.util import values as dpathvalues
from environs import Env as Environs
from executing import Executing as Executing
from furl import furl as furl
from git import GitConfigParser as GitConfigParser
from git import Remote as Remote
from git import Repo as GitRepo
from git.refs import SymbolicReference as GitSymbolicReference
from icecream import IceCreamDebugger as IceCreamDebugger
from jinja2 import Template as Template
from jsonpickle.pickler import Pickler as Pickler
from jsonpickle.unpickler import Unpickler as Unpickler
from jsonpickle.util import importable_name as importable_name
from jsonpickle.util import is_collections as is_collections
from jsonpickle.util import is_installed as is_installed
from jsonpickle.util import is_module_function as is_module_function
from jsonpickle.util import is_noncomplex as is_noncomplex
from jsonpickle.util import is_object as is_object
from jsonpickle.util import is_primitive as is_primitive
from jsonpickle.util import is_reducible as is_reducible
from jsonpickle.util import is_reducible_sequence_subclass as is_reducible_sequence_subclass
from jsonpickle.util import is_unicode as is_unicode
from more_itertools import collapse as collapse
from more_itertools import consume as consume
from more_itertools import first_true as first_true
from more_itertools import map_reduce as map_reduce
from more_itertools import side_effect as side_effect
from nested_lookup import nested_lookup as nested_lookup
from paramiko import AuthenticationException as AuthenticationException
from paramiko import AutoAddPolicy as AutoAddPolicy
from paramiko import BadAuthenticationType as BadAuthenticationType
from paramiko import BadHostKeyException as BadHostKeyException
from paramiko import PasswordRequiredException as PasswordRequiredException
from paramiko import SSHClient as SSHClient
from paramiko import SSHConfig as SSHConfig
from paramiko import SSHException as SSHException
from psutil import MACOS as MACOS
from rich.console import Console as Console
from rich.logging import RichHandler as RichHandler
from rich.pretty import install as pretty_install
from rich.traceback import install as traceback_install
from setuptools import find_packages as find_packages
from setuptools import Distribution as SetUpToolsDistribution
from setuptools.command.install import install as SetUpToolsInstall
from thefuck.utils import Cache as LazyCache
from thefuck.utils import memoize as memoize
from urllib3 import disable_warnings as disable_warnings
from varname import varname as var_name
from verboselogs import NOTICE as NOTICE
from verboselogs import SPAM as SPAM
from verboselogs import SUCCESS as SUCCESS
from verboselogs import VERBOSE as VERBOSE
from verboselogs import VerboseLogger as VerboseLogger
# </editor-fold>
# <editor-fold desc="TypeVars">
_Annotation = TypeVar('_Annotation', bound='Annotation')

_T = TypeVar('_T')
_U = TypeVar('_U')
_KT = TypeVar('_KT')  # Key type.
_VT = TypeVar('_VT')  # Value type.
_T_co = TypeVar('_T_co', covariant=True)  # Any type covariant containers.

# <editor-fold desc="Typing">
Bool = bool
Dict = dict
DictStrAny = dict[str, Any]
ExceptionUnion = Union[tuple[Type[Exception]], Type[Exception]]
Int = int
LST = Union[MutableSequence, MutableSet, tuple]
SeqNoStr = Union[Iterator, KeysView, MutableSequence, MutableSet, tuple, ValuesView]
SeqUnion = Union[AnyStr, ByteString, Iterator, KeysView, MutableSequence, MutableSet, Sequence, tuple, ValuesView]
Str = str
Tuple = tuple
TupleStr = tuple[str, ...]
TupleType = tuple[Type, ...]
# </editor-fold>
# </editor-fold>
# <editor-fold desc="Protected">
RunningLoop: _RunningLoop
DATACLASS_FIELDS: dict[str, DataField]
MISSING_TYPE: Type[_MISSING_TYPE]
POST_INIT_NAME: str
CRLock = _CRLock
Alias = _alias
# </editor-fold>
# <editor-fold desc="Constants">
__all__: TupleStr
AUTHORIZED_KEYS: str
BUILTINS: DictStrAny
BUILTINS_CLASSES: TupleType
BUILTINS_FUNCTIONS: tuple[Union[BuiltinFunctionType, FunctionType], ...]
BUILTINS_OTHER: tuple[Any, ...]
console: Console
cp: console.print
DATACLASS_FIELDS: str
debug: Debug
FILE_DEFAULT: bool
fmic: IceCreamDebugger().format
fmicc: IceCreamDebugger().format
FRAME_SYS_INIT: FrameType
FUNCTION_MODULE: str
GITCONFIG: str
GITHUB_ORGANIZATION: str
ID_RSA: str
ID_RSA_PUB: str
ic: IceCreamDebugger
icc: IceCreamDebugger
IgnoreAttr = Literal['asdict', 'attrs', 'defaults', 'keys', 'kwargs', 'kwargs_dict', 'public', 'values', 'values_dict']
IgnoreCopy = Union[CRLock, Environs, FrameType, GitConfigParser, GitSymbolicReference, Remote]
IgnoreStr = Union[GitConfigParser, GitRepo, ObjectId, PathLib]
LockClass = type(Lock())
NEWLINE: str
SSH_CONFIG: dict[str, str]
SSH_CONFIG_TEXT: str
SSH_DIR: str
STATE_ATTRS: dict[Type, TupleStr]
SUDO_USER: str
SUDO: bool
SUDO_DEFAULT: bool
POST_INIT_NAME: str
print_exception: console.print_exception
PYTHON_SYS: PathLib
PYTHON_SITE: PathLib
# </editor-fold>
# <editor-fold desc="EnumBase">
@total_ordering
class EnumBase(Enum, Generic[_T], _T):
    def __eq__(self, other: Union[str, Access]) -> bool: ...
    def __gt__(self, other: Union[str, Access]) -> bool: ...
    def __hash__(self) -> int: ...
    def __int__(self) -> int: ...
    def _generate_next_value_(self: str, start: Any, count: Any, last_values: Any) -> str: ...
    @classmethod
    @functools.cache
    def asdict(cls) -> DictStrAny: ...
    @classmethod
    @functools.cache
    def attrs(cls) -> list: ...
    @classmethod
    @functools.cache
    def default(cls) -> Any: ...
    @classmethod
    @functools.cache
    def default_attr(cls) -> str: ...
    @classmethod
    @functools.cache
    def default_dict(cls) -> DictStrAny: ...
    @classmethod
    @functools.cache
    def default_value(cls) -> Any: ...
    @property
    @functools.cache
    def describe(self) -> tuple: ...
    @property
    @functools.cache
    def lower(self) -> str: ...
    @classmethod
    @functools.cache
    def values(cls) -> list: ...
EnumBaseAlias: Alias
# </editor-fold>
# <editor-fold desc="Classes: Enums, Named and No Deps">
class AccessMeta(EnumMeta):
    def __getitem__(cls, item: Any) -> Optional[Access]: ...
    def __class_getitem__(mcs, item: Any) -> Optional[Access]: ...
class Access(EnumBase, metaclass=AccessMeta):
    ALL = ...
    PRIVATE = ...
    PROTECTED = ...
    PUBLIC = ...
    @classmethod
    @functools.cache
    def classify(cls, *args: str, **kwargs: Union[Enum, Any]) -> AccessEnumMembers: ...
    @functools.cache
    def es(self, name: str) -> bool: ...
    @functools.cache
    def include(self, name: str) -> Optional[bool]: ...
    @classmethod
    @functools.cache
    def val(cls, name: Union[str, Access]) -> Optional[Access]: ...
    @classmethod
    def __getitem__(cls, item: Union[str, Access]) -> Optional[Access]: ...
_AccessEnumMember = Union[dict[str, Union[Enum, Any]], list[str]]
AccessEnumMembers = NamedTuple('AccessEnumMembers', all=_AccessEnumMember, private=_AccessEnumMember,
                               protected=_AccessEnumMember, public=_AccessEnumMember)
Annotation = NamedTuple('Annotation', any=bool, args=list[Generic[_Annotation], ...], classvar=bool, cls=Type,
                        default=Any, final=bool, hint=Type, initvar=bool, literal=bool, name=str, optional=bool,
                        origin=Any, union=bool)
# Attribute -> "Classes: Deps"
class BaseState:
    __slots__: TupleStr = ...
    __state__: TupleStr = ...
    def __getstate__(self): ...
    def __setstate__(self, state): ...
class BoxKeys(Box[str, Any]):
    def __init__(self, keys: Iterable,
                 value: Optional[Union[Type, Literal['lower']]] = ...) -> None: ...
class ChainRV(EnumBase):
    ALL = ...
    FIRST = ...
    UNIQUE = ...
class Chain(ChainMap):
    rv: ChainRV
    default: Any
    maps: list[Union[Iterable, NamedType, MutableMapping]]
    def __init__(self, *maps: ..., rv: ChainRV = ..., default: Any = ...) -> None: ...
    def __getitem__(self, key: str) -> Any: ...
    def __delitem__(self, key: str) -> None: ...
    def delete(self, key: str) -> None: ...
    def __setitem__(self, key: str, value: Any) -> None: ...
    def set(self, key: str, value: Any) -> None: ...
CacheWrapperInfo = NamedTuple('CacheWrapperInfo', hit=int, passed=int, total=int)
class Executor(EnumBase):
    PROCESS = ...
    THREAD = ...
    NONE = ...
    async def run(self, func: Any, *args: Any, **kwargs: Any) -> Any: ...
# FindUp -> "Classes: Deps"
FrameBase = NamedTuple('FrameBase', back=FrameType, code=CodeType,
                       frame=FrameType, function=str,
                       globals=DictStrAny, lineno=int, locals=DictStrAny, name=str,
                       package=str, path=PathLib, vars=DictStrAny)
class Frame(FrameBase):
    __slots__: TupleStr = ...
    @overload
    def __new__(cls = ..., *args: Str, **kwargs: Any) -> Frame: ...
    @overload
    def __new__(cls = ..., **kwargs: Any) -> Frame: ...
    @property
    @functools.cache
    def asttokens(self) -> ASTTokens: ...
    @property
    @functools.cache
    def executing(self) -> Executing: ...
# FrameSourceNode -> "Classes: Deps"
# GitTop -> "Classes: Deps"
class Is(Generic[_T]):
    __slots__: TupleStr = ...
    data: Union[_T, FrameInfo, FrameType, MutableMapping, TracebackType, Any] = ...
    def __init__(self, data: Any = ...) -> None: ...
    def __getstate__(self) -> DictStrAny: ...
    def __hash__(self) -> int: ...
    def __reduce__(self) -> Tuple[Type[Es], Tuple]: ...
    def __reduce_ex__(self, protocol: int) -> Tuple[Type[Es], Tuple]: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: DictStrAny): ...
    def __str__(self) -> str: ...
    @property
    def _cls(self) -> Type: ...
    @property
    def _func(self) -> Any: ...
    @property
    def annotation(self) -> Bool: ...
    @property
    def annotationstype(self) -> Bool: ...
    @property
    def annotationstype_any(self) -> Bool: ...
    @property
    def annotationstype_sub(self) -> Bool: ...
    @property
    def asdictmethod(self) -> Bool: ...
    @property
    def asdictmethod_sub(self) -> Bool: ...
    @property
    def asdictproperty(self) -> Bool: ...
    @property
    def asdictproperty_sub(self) -> Bool: ...
    @property
    def ast(self) -> Bool: ...
    @property
    def asyncfor(self) -> Bool: ...
    @property
    def asyncfunctiondef(self) -> Bool: ...
    @property
    def asyncgen(self) -> Bool: ...
    @property
    def asyncgenfunction(self) -> Bool: ...
    @property
    def asyncwith(self) -> Bool: ...
    @property
    def attribute(self) -> Bool: ...
    @property
    def await_ast(self) -> Bool: ...
    @property
    def awaitable(self) -> Bool: ...
    @property
    def basestate(self) -> Bool: ...
    @property
    def bool(self) -> Bool: ...
    @property
    def builtin(self) -> Bool: ...
    @property
    def builtinclass(self) -> Bool: ...
    @property
    def builtinfunction(self) -> Bool: ...
    @property
    def builtinfunctiontype(self) -> Bool: ...
    @property
    def bytesio(self) -> Bool: ...
    @property
    def cached_property(self) -> Bool: ...
    @property
    def callable(self) -> Bool: ...
    @property
    def chain(self) -> Bool: ...
    @property
    def chainmap(self) -> Bool: ...
    @property
    def classdef(self) -> Bool: ...
    @property
    def classmethoddescriptortype(self) -> Bool: ...
    @property
    def classvar(self) -> Bool: ...
    @property
    def clsmethod(self) -> Bool: ...
    @property
    def codetype(self) -> Bool: ...
    @property
    def collections(self) -> Bool: ...
    @property
    def container(self) -> Bool: ...
    @property
    def coro(self) -> Bool: ...
    @property
    def coroutine(self) -> Bool: ...
    @property
    def coroutinefunction(self) -> Bool: ...
    @property
    def default_factory(self) -> Bool: ...
    @property
    def datafield(self) -> Bool: ...
    @property
    def datatype(self) -> Bool: ...
    @property
    def datatype_any(self) -> Bool: ...
    @property
    def datatype_sub(self) -> Bool: ...
    @property
    def defaultdict(self) -> Bool: ...
    @property
    def deleter(self) -> Bool: ...
    @property
    def dict(self) -> Bool: ...
    @property
    def dicttype(self) -> Bool: ...
    @property
    def dicttype_sub(self) -> Bool: ...
    @property
    def dynamicclassattribute(self) -> Bool: ...
    @property
    def dlst(self) -> Bool: ...
    @property
    def enum(self) -> Bool: ...
    @property
    def enum_sub(self) -> Bool: ...
    @property
    def enumbase(self) -> Bool: ...
    @property
    def enumbase_sub(self) -> Bool: ...
    @property
    def even(self) -> Bool: ...
    @property
    def fileio(self) -> Bool: ...
    @property
    def float(self) -> Bool: ...
    @property
    def frameinfo(self) -> Bool: ...
    @property
    def frametype(self) -> Bool: ...
    @property
    def functiondef(self) -> Bool: ...
    @property
    def functiontype(self) -> Bool: ...
    @property
    def generator(self) -> Bool: ...
    @property
    def generatortype(self) -> Bool: ...
    @property
    def genericalias(self) -> Bool: ...
    @property
    def getattrnobuiltintype(self) -> Bool: ...
    @property
    def getattrnobuiltintype_sub(self) -> Bool: ...
    @property
    def getattrtype(self) -> Bool: ...
    @property
    def getattrtype_sub(self) -> Bool: ...
    @property
    def getsetdescriptortype(self) -> Bool: ...
    @property
    def gettype(self) -> Bool: ...
    @property
    def gettype_sub(self) -> Bool: ...
    @property
    def hashable(self) -> Bool: ...
    @property
    def import_ast(self) -> Bool: ...
    @property
    def importfrom(self) -> Bool: ...
    @property
    def initvar(self) -> Bool: ...
    @property
    def installed(self) -> Bool: ...
    def instance(self, *args: Type) -> Bool: ...
    @property
    def int(self) -> Bool: ...
    @property
    def io(self) -> Bool: ...
    @property
    def iterable(self) -> Bool: ...
    @property
    def iterator(self) -> Bool: ...
    @property
    def lambdatype(self) -> Bool: ...
    @property
    def list(self) -> Bool: ...
    @property
    def lst(self) -> Bool: ...
    @property
    def mappingproxytype(self) -> Bool: ...
    @property
    def mappingproxytype_sub(self) -> Bool: ...
    @property
    def memberdescriptor(self) -> Bool: ...
    @property
    def memberdescriptortype(self) -> Bool: ...
    @property
    def meta(self) -> Bool: ...
    @property
    def meta_sub(self) -> Bool: ...
    @property
    def metatype(self) -> Bool: ...
    @property
    def metatype_sub(self) -> Bool: ...
    @property
    def method(self) -> Bool: ...
    @property
    def methoddescriptor(self) -> Bool: ...
    @property
    def methoddescriptortype(self) -> Bool: ...
    @property
    def methodtype(self) -> Bool: ...
    @property
    def methodwrappertype(self) -> Bool: ...
    @property
    def methodwrappertype_sub(self) -> Bool: ...
    @property
    def missing(self) -> Bool: ...
    @property
    def mlst(self) -> Bool: ...
    @property
    def mm(self) -> Bool: ...
    @property
    def moduletype(self) -> Bool: ...
    @property
    def module_function(self) -> Bool: ...
    @property
    def noncomplex(self) -> Bool: ...
    @property
    def namedtype(self) -> Bool: ...
    @property
    def namedtype_any(self) -> Bool: ...
    @property
    def namedtype_sub(self) -> Bool: ...
    @property
    def named_annotationstype(self) -> Bool: ...
    @property
    def named_annotationstype_sub(self) -> Bool: ...
    @property
    def none(self) -> Bool: ...
    @property
    def object(self) -> Bool: ...
    @property
    def pathlib(self) -> Bool: ...
    @property
    def picklable(self) -> Bool: ...
    @property
    def primitive(self) -> Bool: ...
    @property
    def prop(self) -> Bool: ...
    @property
    def property_any(self) -> Bool: ...
    @property
    def reducible(self) -> Bool: ...
    @property
    def reducible_sequence_subclass(self) -> Bool: ...
    @property
    def routine(self) -> Bool: ...
    @property
    def sequence(self) -> Bool: ...
    @property
    def sequence_sub(self) -> Bool: ...
    @property
    def _set(self) -> Bool: ...
    @property
    def setter(self) -> Bool: ...
    @property
    def simple(self) -> Bool: ...
    @property
    def sized(self) -> Bool: ...
    @property
    def slotstype(self) -> Bool: ...
    @property
    def slotstype_sub(self) -> Bool: ...
    @property
    def static(self) -> Bool: ...
    @property
    def str(self) -> Bool: ...
    @functools.cache
    def subclass(self, *args: Type) -> Bool: ...
    @property
    def stringio(self) -> Bool: ...
    @property
    def tracebacktype(self) -> Bool: ...
    @property
    def tuple(self) -> Bool: ...
    @property
    def type(self) -> Bool: ...
    @property
    def unicode(self) -> Bool: ...
    @property
    def wrapperdescriptortype(self) -> Bool: ...
    def __class_getitem__(cls, item: Any) -> GenericAlias: ...
class Kind(EnumBase):
    CLASS = ...
    DATA = ...
    METHOD = ...
    PROPERTY = ...
    STATIC = ...
class ModuleBase(EnumBase):
    @property
    @functools.cache
    def get(self): ...
    @property
    @functools.cache
    def load(self): ...
class Module(ModuleBase):
    FUNCTOOLS = ...
    TYPING = ...
class NBase(EnumBase):
    def _generate_next_value_(self: str, start: Any, count: Any, last_values: Any) -> str: ...
    def get(self, obj: Any, default: Any = ..., setvalue: bool = ...) -> Any: ...
    def getf(self, obj: Any, default: Any = ...) -> Any: ...
    @property
    @functools.cache
    def getter(self) -> attrgetter: ...
    def has(self, obj: Any) -> bool: ...
    def mro_first_data(self, obj: Any) -> Union[Any, NotImplemented]: ...
    def mro_first_dict(self, obj: Any, mro: Tuple[Type[Any, DataType], ...] = ...) -> Union[Any, NotImplemented]: ...
    def mro_first_dict_no_object(self, obj: Any) -> Union[Any, NotImplemented]: ...
    def mro_values(self, obj: Any) -> TupleStr: ...
    def mro_values_default(self, obj: Any) -> tuple[Union[str, Type[Any]], ...]: ...
    def slot(self, obj: Any) -> bool: ...
    def slots_include(self, obj: Any) -> TupleStr: ...
class N(NBase):
    ABOUT = ...
    ABSTRACTMETHODS = ...
    AUTHOR = ...
    ADAPT = ...
    ALL = ...
    ALLOC = ...
    ANNOTATIONS = ...
    ARGS = ...
    ASDICT = ...
    ATTRIBUTES = ...
    BASE = ...
    BASICSIZE = ...
    BUILD_CLASS = ...
    BUILTINS = ...
    CACHE_CLEAR = ...
    CACHE_INFO = ...
    CACHED = ...
    CLASS = ...
    CODE = ...
    CONFORM = ...
    CONTAINS = ...
    CREDITS = ...
    COPY = ...
    COPYRIGHT = ...
    CVSID = ...
    DATACLASS_FIELDS = ...
    DATACLASS_PARAMS = ...
    DATE = ...
    DECIMAL_CONTEXT = ...
    DEEPCOPY = ...
    DELATTR = ...
    DICT = ...
    DICTOFFSET = ...
    DIR = ...
    DOC = ...
    DOCFORMAT = ...
    EMAIL = ...
    EQ = ...
    EXCEPTION = ...
    FILE = ...
    FLAGS = ...
    GET = ...
    GETATTRIBUTE = ...
    GETFORMAT = ...
    GETINITARGS = ...
    GETITEM = ...
    GETNEWARGS = ...
    GETSTATE = ...
    HASH = ...
    HASH_EXCLUDE = ...
    IGNORE_ATTR = ...
    IGNORE_COPY = ...
    IGNORE_HASH = ...
    IGNORE_INIT = ...
    IGNORE_KWARG = ...
    IGNORE_REPR = ...
    IGNORE_STR = ...
    INIT = ...
    INIT_SUBCLASS = ...
    INITIALIZING = ...
    ISABSTRACTMETHOD = ...
    ITEMSIZE = ...
    LEN = ...
    LIBMPDEC_VERSION = ...
    LOADER = ...
    LTRACE = ...
    MEMBERS = ...
    METHODS = ...
    MODULE = ...
    MP_MAIN = ...
    MRO = ...
    NAME = ...
    NEW_MEMBER = ...
    NEW_OBJ = ...
    NEW_OBJ_EX = ...
    OBJ_CLASS = ...
    PACKAGE = ...
    POST_INIT = ...
    PREPARE = ...
    PYCACHE = ...
    QUALNAME = ...
    REDUCE = ...
    REDUCE_EX = ...
    REPR = ...
    REPR_EXCLUDE = ...
    REPR_NEWLINE = ...
    REPR_PPROPERTY = ...
    RETURN = ...
    SELF_CLASS = ...
    SETATTR = ...
    SETFORMAT = ...
    SETSTATE = ...
    SIGNATURE = ...
    SIZEOF = ...
    SLOTNAMES = ...
    SLOTS = ...
    SPEC = ...
    STATE = ...
    STATUS = ...
    STR = ...
    SUBCLASSHOOK = ...
    TEST = ...
    TEXT_SIGNATURE = ...
    THIS_CLASS = ...
    TRUNC = ...
    VERSION = ...
    WARNING_REGISTRY = ...
    WEAKREF = ...
    WEAKREFOFFSET = ...
    WRAPPED = ...
    _asdict = ...
    _cls = ...
    _copy = ...
    _count = ...
    _data = ...
    _extend = ...
    _external = ...
    _field_defaults = ...
    _fields = ...
    _file = ...
    _filename = ...
    _frame = ...
    _func = ...
    _function = ...
    _get = ...
    _globals = ...
    _id = ...
    _index = ...
    _ip = ...
    _item = ...
    _items = ...
    _key = ...
    _keys = ...
    _kind = ...
    _locals = ...
    _name = ...
    _node = ...
    _origin = ...
    _obj = ...
    _object = ...
    _path = ...
    _repo = ...
    _RV = ...
    _pypi = ...
    _remove = ...
    _reverse = ...
    _sort = ...
    _source = ...
    _update = ...
    _value = ...
    _values = ...
    _vars = ...
    add = ...
    append = ...
    asdict = ...
    cls = ...
    clear = ...
    co_name = ...
    code_context = ...
    copy = ...
    count = ...
    data = ...
    default_factory = ...
    endswith = ...
    extend = ...
    external = ...
    f_back = ...
    f_code = ...
    f_globals = ...
    f_lineno = ...
    f_locals = ...
    file = ...
    filename = ...
    frame = ...
    func = ...
    function = ...
    get_ = ...
    globals = ...
    id = ...
    index = ...
    ip = ...
    item = ...
    items = ...
    key = ...
    keys = ...
    kind = ...
    lineno = ...
    locals = ...
    name = ...
    node = ...
    origin = ...
    obj = ...
    object = ...
    path = ...
    repo = ...
    rv = ...
    pop = ...
    popitem = ...
    pypi = ...
    remove = ...
    reverse = ...
    self_ = ...  # To avoid conflict with Enum
    sort = ...
    source = ...
    startswith = ...
    tb_frame = ...
    tb_lineno = ...
    tb_next = ...
    update = ...
    value = ...
    values = ...
    vars = ...
class PathGit(EnumBase):
    PATH = ...
    URL = ...
    def cmd(self, path: PathLikeStr = ...) -> Optional[Path, furl]: ...
    @classmethod
    def top(cls, path: PathLikeStr = ...) -> GitTop: ...
class PathInstallScript(SetUpToolsInstall):
    def run(self): ...
    @classmethod
    def path(cls) -> str: ...
class PathIs(EnumBase):
    DIR = ...
    FILE = ...
class PathMode(EnumBase):
    DIR = ...
    FILE = ...
    X = ...
class PathOption(EnumBase):
    BOTH = ...
    DIRS = ...
    FILES = ...
class PathOutput(EnumBase):
    BOTH = ...
    BOX = ...
    DICT = ...
    LIST = ...
    NAMED = ...
    TUPLE = ...
class PathSuffix(EnumBase):
    NO = ...
    BASH = ...
    ENV = ...
    GIT = ...
    INI = ...
    J2 = ...
    JINJA2 = ...
    LOG = ...
    MONGO = ...
    OUT = ...
    PY = ...
    RLOG = ...
    SH = ...
    TOML = ...
    YAML = ...
    YML = ...
    @property
    def dot(self) -> str: ...
class Path(PathLib, pathlib.PurePosixPath, Generic[_P], str):
    __slots__ = ('_previous', )
    def __call__(self, name: Optional[str] = ..., file: bool = ...,
                 group: Optional[Union[str, int]] = ...,
                 mode: Optional[Union[int, str]] = ..., su: bool = ...,
                 u: Optional[Union[str, int]] = ...) -> Path: ...
    def __contains__(self, value: Iterable[str]) -> bool: ...
    def __eq__(self, other: Union[Path, tuple[str]]) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def append_text(self, data, encoding=None, errors=None): ...
    @property
    @contextmanager
    def cd(self) -> Path: ...
    def c_(self, p: Any = ...) -> Path: ...
    def chdir(self): ...
    def chmod(self, mode: Optional[Union[int, str]] = ...) -> Path: ...
    def chown(self, group: Optional[Union[str, int]] = ..., u: Optional[Union[str, int]] = ...) -> Path: ...
    @property
    def endseparator(self) -> str: ...
    def fd(self, *args, **kwargs): ...
    @property
    def find_packages(self) -> list: ...
    def find_up(self, file: PathIs = ..., name: Union[str, PathSuffix] = ...) -> FindUp: ...
    def has(self, value: str) -> bool: ...
    @staticmethod
    def home(name: str = ..., file: bool = ...) -> Path: ...
    @property
    def installed(self) -> Path: ...
    @property
    def installedbin(self) -> Path: ...
    @property
    def installedpy(self) -> Path: ...
    def _is_file(self) -> Optional[str]: ...
    def j2(self, dest: Any = ..., stream: bool = ..., variables: dict = ...) -> Union[list, dict]: ...
    def mkdir(self, name: Optional[str] = ..., group: Optional[Union[str, int]] = ...,
              mode: Optional[Union[int, str]] = ..., su: bool = ...,
              u: Optional[Union[str, int]] = ...) -> Path: ...
    @property
    def modname_from_file(self) -> Optional[str]: ...
    @property
    def module_from_file(self) -> Optional[ModuleType]: ...
    @property
    def path(self) -> Path: ...
    @property
    def parent_if_file(self) -> Path: ...
    @property
    def pwd(self) -> Path: ...
    @property
    def read_text_tokenize(self) -> str: ...
    def relative(self, p: Any) -> Path: ...
    @property
    def resolved(self) -> Path: ...
    def rm(self, missing_ok=...): ...
    def scan(self, option: PathOption = ...,
             output: PathOutput = ..., suffix: PathSuffix = ...,
             level: bool = ..., hidden: bool = ..., frozen: bool = ...) -> Union[Box, dict, list]: ...
    @property
    def stemfull(self) -> Path: ...
    @property
    def str(self) -> str: ...
    @classmethod
    def sys(cls) -> Path: ...
    def templates(self, stream: bool = ...) -> dict[str, Union[Template.stream, Template.render]]: ...
    @property
    def text(self) -> str: ...
    @classmethod
    @contextmanager
    def tmp(cls) -> Path: ...
    @staticmethod
    def to_iter(value: Iterable) -> list: ...
    def to_name(self, rel: Path) -> str: ...
    def touch(self, name: Optional[str] = ..., group: Optional[Union[str, int]] = ...,
              mode: Optional[Union[int, str]] = ..., su: bool = ...,
              u: Optional[Union[str, int]] = ...) -> Path: ...
class Re(EnumBase):
    ALL = ...
    ASYNCDEF = ...
    BLOCK = ...
    DEF = ...
    DECORATOR = ...
    LAMBDA = ...
    PRIVATE = ...
    PROTECTED = ...
    PUBLIC = ...
class Source(executing.Source):
    __slots__: TupleStr = ...
    _nodes_by_line: defaultdict[int, AST]
    _qualnames: dict[tuple[str, int], str]
    filename: str
    lines: list[str, ...]
    text: str
    tree: AST
    def __init__(self, filename: Str, lines: list[str, ...]) -> None: ...
class SourceNode:
    code: str
    code_line: tuple[str, int]
    complete: str
    complete_line: tuple[str, int]
    context: TupleStr
    es: Es
    index: int
    __slots__: TupleStr = ...
    def __init__(self, es: Es) -> None: ...
    def __repr__(self) -> Str: ...
    @functools.cache
    def get(self, complete: bool = ..., line: bool = ...) -> Union[Tuple[str, int], str]: ...
    @functools.cache
    def node(self, complete: bool = ..., line: bool = ...) -> Union[Tuple[AST, int], AST]: ...
    @functools.cache
    def open(self, line: bool = ...) -> Union[Tuple[str, int], str]: ...
class UserActual:
    ROOT: bool = ...
    SUDO: bool = ...
    SUDO_USER: str = ...
    def __init__(self) -> None: ...
class UserProcess:
    id: int = ...
    gecos: str = ...
    gid: int = ...
    gname: str = ...
    home: Path = ...
    name: str = ...
    passwd: pwd.struct_passwd = ...
    ROOT: bool = ...
    shell: Path = ...
    ssh: Path = ...
    SUDO: bool = ...
    SUDO_USER: str = ...
    auth_keys: Path = ...
    id_rsa: Path = ...
    id_rsa_pub: Path = ...
    git_config_path: Path = ...
    git_config: GitConfigParser = ...
    github_username: str = ...
class User:
    actual: UserActual = ...
    process: UserProcess = ...
    gecos: str = ...
    gid: int = ...
    gname: str = ...
    home: Path = ...
    id: int = ...
    name: str = ...
    passwd: pwd.struct_passwd = ...
    ROOT: bool = ...
    shell: Path = ...
    ssh: Path = ...
    SUDO: bool = ...
    SUDO_USER: str = ...
    auth_keys: Path = ...
    id_rsa: Path = ...
    id_rsa_pub: Path = ...
    git_config_path: Path = ...
    git_config: GitConfigParser = ...
    github_username: str = ...
    GIT_SSH_COMMAND: str = ...
    def __contains__(self, item: Union[User, str]) -> bool: ...
    def __eq__(self, other: User) -> bool: ...
    def __hash__(self) -> int: ...
    @staticmethod
    def sudo(command, su: bool = ...) -> str: ...

# </editor-fold>
# <editor-fold desc="Classes: Deps">
class Es(Generic[_T], Is):
    __slots__: TupleStr = ...
    _annotations: Dict[str, Annotation]
    _attributes: Attributes
    _classified: Tuple[inspect.Attribute, ...]
    _classified_dict: Dict[str, inspect.Attribute]
    _stack_index: Int
    data: Union[_T, FrameInfo, FrameType, MutableMapping, TracebackType, Any] = ...
    def __init__(self, data: Any = ...) -> None: ...
    def __call__(self, *args: Type) -> Bool: ...
    def __getstate__(self) -> DictStrAny: ...
    def __hash__(self) -> int: ...
    def __reduce__(self) -> Tuple[Type[Es], Tuple]: ...
    def __reduce_ex__(self, protocol: int) -> Tuple[Type[Es], Tuple]: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: DictStrAny): ...
    def __str__(self) -> str: ...
    # <editor-fold desc="Es - Bool">
    def getsetdescriptor(self, n: Any = None) -> Bool: ...
    def has(self, name: Any) -> Bool: ...
    def in_prop(self, name: Union[Enum, str], exclude_coro: bool = ...) -> Bool: ...
    def public_prop(self, name: Union[N, str] = ..., exclude_coro: bool = ...) -> Bool: ...
    def readonly(self, name: Union[N, str] = ...) -> Union[Bool, Exception]: ...
    def slot(self, name: Union[N, Str]) -> Bool: ...
    def writeable(self, name: Union[N, Str]) -> Bool: ...
    # </editor-fold>
    # <editor-fold desc="Es - Inspect">
    def annotations(self, stack: Union[FrameType, int] = ...) -> Dict[str, Annotation]: ...
    def attributes(self, stack: Union[FrameType, int] = ..., prop: bool = ...,
                   repr_: Access = ..., exclude_coro: bool = ...) -> Attributes: ...
    @property
    def classified(self) -> Tuple[inspect.Attribute, ...]: ...
    @property
    def classified_dict(self) -> Dict[str, inspect.Attribute]: ...
    @property
    def cls(self) -> Type: ...
    @property
    def clsname(self) -> str: ...
    @property
    def clsqual(self) -> str: ...
    @property
    def es_cls(self) -> Es[Type]: ...
    @property
    def fields(self) -> Dict[str, DataField]: ...
    @property
    def first_builtin(self) -> Type: ...
    @property
    def importable_name_cls(self) -> Optional[str]: ...
    @property
    def importable_name_data(self) -> Optional[str]: ...
    @property
    def modname(self) -> Optional[str]: ...
    @property
    def mro(self) -> Tuple[Type[Any, DataType], ...]: ...
    @property
    def mro_and_data(self) -> Tuple[Type[Any, _T], ...]: ...
    def mro_first_data(self, name: Union[N, Str]) -> Union[Any, NotImplemented]: ...
    def mro_first_dict(self, name: Union[N, Str],
                       mro: Tuple[Type[Any, DataType], ...] = ...) -> Union[Any, NotImplemented]: ...
    def mro_first_dict_no_object(self, name: Union[N, Str]) -> Union[Any, NotImplemented]: ...
    def mro_values(self, name: Union[N, Str]) -> TupleStr: ...
    def mro_values_default(self, name: Union[N, Str]) -> Tuple[Union[str, Type[Any]], ...]: ...
    @property
    def name(self) -> Optional[str]: ...
    @classmethod
    def prop_getter(cls, prop: property) -> Union[attrgetter, NotImplemented]: ...
    @property
    def slots(self) -> TupleStr: ...
    def slots_include(self, name: Union[N, Str]) -> TupleStr: ...
    @property
    def super(self) -> Type: ...
    # </editor-fold>
    # <editor-fold desc="Es - Utils">
    @property
    def deepcopy(self) -> Any: ...
    @property
    def frame(self) -> Optional[Frame]: ...
    @property
    def framebase(self) -> Optional[FrameBase]: ...
    @property
    def framesourcenode(self) -> Optional[FrameSourceNode]: ...
    def get(self, name: Any, default: Any = ..., setvalue: bool = ...) -> Any: ...
    def getf(self, name: Union[Enum, Str, Any] = ..., default: Any = ...) -> Any: ...
    @property
    def path(self) -> PathLib: ...
    @property
    def pickles(self) -> Optional[bytes]: ...
    def set(self, name: Any, value: Any = ...) -> Any: ...
    @property
    def sourcenode(self) -> SourceNode: ...
    def state(self, data: DictStrAny = ...) -> Union[DictStrAny, Any]: ...
    @property
    def state_methods(self) -> Any: ...
    @property
    def unpickles(self) -> Any: ...
    # </editor-fold>
    def __class_getitem__(cls, item: Any) -> GenericAlias: ...
Attribute = NamedTuple('Attribute', access=Access, annotation=Annotation, classvar=bool, copy=bool, coro=bool,
                       dataclass=bool, default=Union[Any, NotImplemented], defaultfactory=bool, defining=type,
                       dict=bool, dictslot=bool,
                       es=Es, field=Es[DataField], hash=bool, ignore=bool,
                       init=bool, initvar=bool, kind=Kind, name=str, named=bool, object=Any, publicprop=bool,
                       qual=str, repre=bool, slot=bool, state=bool, str=bool, type=bool, value=Any)
class Attributes(dict[str, Attribute], MutableMapping[_KT, Attribute], Mapping[_KT, Attribute]):
    STATE: TupleStr = ...
    __slots__: TupleStr = ...
    def __hash__(self) -> int: ...
    def __new__(cls: Type[Attributes], *args: str, **kwargs: Attribute) -> Attributes: ...
    @overload
    def __init__(self, *args: Iterable[Tuple[_KT, Attribute]], **kwargs: Attribute) -> None: ...
    @overload
    def __init__(self, **kwargs: Attribute) -> None: ...
    @overload
    def __init__(self, map: SupportsKeysAndGetItem[_KT, Attribute], **kwargs: Attribute) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Tuple[_KT, Attribute]]) -> None: ...
    def __repr__(self) -> str: ...
    @functools.cache
    def classmethods(self, access: Access = ...) -> Attributes: ...
    @property
    def data_all(self) -> Attributes: ...
    @property
    def data_protected(self) -> Attributes: ...
    @functools.cache
    def filter(self, include: Access = ..., key: Callable[..., bool] = ...,
               value: Callable[..., bool] = ...) -> Attributes: ...
    @property
    def state(self) -> Attributes: ...
FindUp = NamedTuple('FindUp', path=Optional[Path], previous=Optional[Path])
FrameSourceNode = NamedTuple('FrameSourceNode', framebase=FrameBase, sourcenode=SourceNode)
GitTop = NamedTuple('GitTop', name=str, origin=furl, path=Path)
PathLikeStr = Union[PathLike, Path, str]
class StateEnv(Environs, BaseState):
    def __init__(self, *, eager: bool = ..., expand_vars: bool = ...): ...
# </editor-fold>
# <editor-fold desc="Functions">
def aioloop() -> Optional[RunningLoop]: ...
def allin(origin: Iterable, destination: Iterable) -> bool: ...
def annotations(obj: Any, stack: Union[FrameType, int] = ...,
                sequence: bool = ...) -> Union[dict[str, Annotation], dict]: ...
def annotations_init(cls: Type[Union[NamedAnnotationsType, NamedTuple]], stack: Union[FrameType, int] = ...,
                     optional: bool = ..., **kwargs) -> NamedTuple: ...
def anyin(origin: Iterable, destination: Iterable) -> Optional[Any]: ...
class _cache_wrapper(Generic[_T]):
    __wrapped__: Callable[..., _T]
    cache_hit: int = ...
    cache_passed: int = ...
    cache_total: int = ...
    def __call__(self, *args: Any, **kwargs: Any) -> _T: ...
    def cache_clear(self) -> None: ...
    def cache_info(self) -> CacheWrapperInfo: ...
class cache:
    enabled: bool = ...
    memo: dict[Callable, dict[bytes, Any]] = ...
    def __call__(self, *args: Any, **kwargs: Any) -> _T: ...
    @staticmethod
    def cache_clear() -> None: ...
    @staticmethod
    def cache_info() -> CacheWrapperInfo: ...
    @staticmethod
    def wrapper(*args: Any, **kwargs: Any) -> _cache_wrapper: ...
def cmd(command: Iterable,
        exc: bool = ...,
        lines: bool = ...,
        shell: bool = ...,
        py: bool = ...,
        pysite: bool = ...) -> Union[CompletedProcess, int, list, str]: ...
def cmdname(func: Callable, sep: str = ...) -> str: ...
def current_task_name() -> str: ...
@singledispatch
def delete(data: Union[MutableMapping, list], key: Iterable = ...) -> Optional[dict]: ...
@delete.register
def delete_list(data: list, key: Iterable = ...) -> Optional[list]: ...
def dict_sort(data: dict, ordered: bool = ..., reverse: bool = ...) -> Union[dict, OrderedDict]:...
def effect(apply: Callable, data: Iterable) -> NoReturn:...
def enumvalue(data: Any) -> Any:...
def get(data: Any, *args: Any, default: Any = ..., names: bool = ..., one: bool = ..., recursive: bool = ...,
        setvalue: bool = ...) -> Union[defaultdict[str, list], DictStrAny, list, Any]:...
@overload
@functools.cache
def getnostr(data: str, attr: Optional[str] = ...) -> str:...
@overload
@functools.cache
def getnostr(data: Any, attr: Optional[str] = ...) -> str:...
def getset(data: Any, name: str, default: Any = ..., setvalue: bool = ...) -> Any: ...
def iseven(number: int) -> bool: ...
def in_dict(data: MutableMapping, items: Optional[dict] = ..., **kwargs: Any) -> bool: ...
def join_newline(data: Iterable[str]) -> str: ...
def map_reduce_even(iterable: Iterable[_T]) -> list[_U, list[_T]]:...
def map_with_args(data: Any, func: Callable, /, *args, pred: Callable = lambda x: True if x else False,
                  split: str = ' ', **kwargs) -> list: ...
def newprop(name: str = ..., default: Optional[Any, Callable, partial] = ...) -> property: ...
def noexception(
        func: Callable[..., _T],
        *args,
        default_: Any = ...,
        exc_: ExceptionUnion = ...,
        **kwargs: Any
) -> _T: ...
def prefixed(name: str) -> str: ...
def repr_format(obj: Any, attrs: Iterable[str], clear: bool = ..., newline: bool = ...) -> str: ...
@decorator
def runwarning(func: Callable, *args: Any, **kwargs: Any) -> Any: ...
def split_sep(sep: str = ...) -> dict: ...
def startswith(name: str, builtin: bool = ...) -> bool: ...
def to_camel(text: str, replace: bool = True) -> str: ...
def to_iter(data: Any, split: str = ...) -> Union[Sized, MutableMapping, Sequence, MutableSequence]: ...
def to_vars(): ...
def token_open(file: Union[PathLike, PathLib, str]) -> str: ...
def varname(index: int = ..., lower: bool = ..., sep: str = ...) -> Optional[str]: ...
def yield_if(data: Any, pred: Callable = ..., split: str = ...,
             apply: Union[Callable, tuple[Callable, ...]] = ...) -> Generator: ...
def yield_last(data: Any) -> Iterator[tuple[bool, Any, Optional[Any, None]]]: ...
# </editor-fold>
class CmdError(Exception):
    def __init__(self, rv: CompletedProcess) -> None: ...
class CmdAioError(CmdError):
    def __init__(self, rv: CompletedProcess) -> None: ...
# </editor-fold>
# <editor-fold desc="Types">
class AnnotationsType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class AsDictMethodType(metaclass=ABCMeta):
    @abstractmethod
    def asdict(self, *args: Any, **kwargs: Any) -> DictStrAny: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class AsDictPropertyType(metaclass=ABCMeta):
    @property
    @abstractmethod
    def asdict(self) -> DictStrAny: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class DataType(metaclass=ABCMeta):
    __annotations__: MappingProxyType
    __dataclass_fields__: dict[str, DataField]
    def __repr__(self) -> str: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class DictType(metaclass=ABCMeta):
    __dict__: MappingProxyType
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class GetAttrNoBuiltinType(metaclass=ABCMeta):
    def __getattribute__(self, name: str) -> Any: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class GetAttrType(metaclass=ABCMeta):
    def __getattribute__(self, name: str) -> Any: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
@runtime_checkable
class GetItemSupportType(Protocol):
    __slots__: TupleStr = ...
    @overload
    @abstractmethod
    def __getitem__(self, i: int) -> _T_co: ...
    @overload
    @abstractmethod
    def __getitem__(self, s: slice) -> Sequence[_T_co]: ...
@runtime_checkable
class GetSupportType(Protocol):
    __slots__: TupleStr = ...
    @abstractmethod
    def get(self, name: str, default: Any = ...) -> Any: ...
@runtime_checkable
class GetType(Protocol):
    def get(self, name: str, default: Any = ...) -> Any:
        pass
class NamedType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    def _asdict(self) -> DictStrAny: ...
    _fields: TupleStr
    _field_defaults: DictStrAny
class NamedAnnotationsType(metaclass=ABCMeta):
    __annotations__: MappingProxyType
    _fields: TupleStr
    _field_defaults: MappingProxyType
    def _asdict(self) -> DictStrAny: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class SlotsType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
# </editor-fold>
# <editor-fold desc="Echo">
def black(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def blue(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def cyan(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def green(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def magenta(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
            blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def red(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
        blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def white(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def yellow(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bblack(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bblue(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bcyan(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bgreen(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bmagenta(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
             blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bred(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bwhite(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def byellow(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
            blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
# </editor-fold>
# <editor-fold desc="Test">
class TestAsync:
    _async_classmethod: str = ...
    _classmethod: str = ...
    _async_method: str = ...
    _method: str = ...
    _cprop: str = ...
    _async_pprop: str = ...
    _pprop: str = ...
    _async_prop: str = ...
    _prop: str = ...
    _async_staticmethod: str = ...
    _staticmethod: str = ...
    @classmethod
    async def async_classmethod(cls) -> str: ...
    @classmethod
    def classmethod(cls) -> str: ...
    async def async_method(self) -> str: ...
    def method(self) -> str: ...
    @property
    def cprop(self) -> str: ...
    @property
    async def async_pprop(self) -> str: ...
    @property
    def pprop(self) -> str: ...
    @property
    async def async_prop(self) -> str: ...
    @property
    def prop(self) -> str: ...
    @staticmethod
    async def async_staticmethod() -> str: ...
    @staticmethod
    def staticmethod() -> str: ...
@dataclass
class TestData:
    dataclass_classvar: ClassVar[str] = ...
    dataclass_default: str = ...
    dataclass_default_factory: Union[dict, str] = ...
    dataclass_default_factory_init: Union[dict, str] = ...
    dataclass_default_init: str = ...
    dataclass_initvar: InitVar[str] = ...
    dataclass_str: str = ...
    def __post_init__(self, dataclass_initvar: str) -> None: ...
    def __class_getitem__(cls, item: Any) -> GenericAlias: ...
class TestDataDictMix(TestData):
    subclass_annotated_str: str = ...
    subclass_classvar: ClassVar[str] = ...
    subclass_str: str = ...
    def __init__(self, dataclass_initvar: str = ..., subclass_dynamic: str = ...,) -> None: ...
class TestDataDictSlotMix(TestDataDictMix):
    __slots__ = ('_slot_property', 'slot', )
    _slot_property: str
    slot: str
    def __init__(self, dataclass_initvar: str =  ..., slot_property: str =  ..., slot: str =  ...) -> None: ...
    @property
    def slot_property(self) -> str: ...
# </editor-fold>
# <editor-fold desc="Instances">
user: User
# </editor-fold>
