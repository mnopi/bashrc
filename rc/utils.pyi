# <editor-fold desc="Imports">
import functools
import pathlib
from abc import ABCMeta
from abc import abstractmethod
from ast import AST as AST
from ast import AsyncFor as AsyncFor
from ast import AsyncFunctionDef as AsyncFunctionDef
from ast import AsyncWith as AsyncWith
from ast import Await as Await
from ast import ClassDef as ClassDef
from ast import FunctionDef as FunctionDef
from ast import get_source_segment as get_source_segment
from ast import Import as Import
from ast import ImportFrom as ImportFrom
from ast import NodeVisitor as NodeVisitor
from ast import walk as walk
from asyncio import Semaphore
from asyncio.events import _RunningLoop
from collections import defaultdict
from collections import deque
from collections.abc import AsyncGenerator as AsyncGenerator
from collections.abc import AsyncIterable as AsyncIterable
from collections.abc import AsyncIterator as AsyncIterator
from collections.abc import Awaitable as Awaitable
from collections.abc import ByteString as ByteString
from collections.abc import Callable as Callable
from collections.abc import Collection as Collection
from collections.abc import Container as Container
from collections.abc import Coroutine as Coroutine
from collections.abc import Generator as Generator
from collections.abc import Hashable as Hashable
from collections.abc import ItemsView as ItemsView
from collections.abc import Iterable as Iterable
from collections.abc import Iterator as Iterator
from collections.abc import KeysView as KeysView
from collections.abc import Mapping as Mapping
from collections.abc import MappingView as MappingView
from collections.abc import MutableMapping as MutableMapping
from collections.abc import MutableSequence as MutableSequence
from collections.abc import MutableSet as MutableSet
from collections.abc import Reversible as Reversible
from collections.abc import Sequence as Sequence
from collections.abc import Set as Set
from collections.abc import Sized as Sized
from collections.abc import ValuesView as ValuesView
from concurrent.futures.process import ProcessPoolExecutor as ProcessPoolExecutor
from concurrent.futures.thread import ThreadPoolExecutor as ThreadPoolExecutor
from dataclasses import _MISSING_TYPE
from dataclasses import dataclass
from dataclasses import Field
from dataclasses import field as datafield
from dataclasses import fields as datafields
from dataclasses import InitVar
from enum import Enum
from functools import partial
from functools import singledispatch
from functools import singledispatchmethod
from inspect import FrameInfo
from inspect import stack as insstack
from json import JSONEncoder
from logging import Logger
from operator import attrgetter
from os import PathLike
from pathlib import Path as PathLib
from subprocess import CompletedProcess
from threading import _CRLock
from types import BuiltinFunctionType
from types import DynamicClassAttribute
from types import FrameType
from types import FunctionType
from types import GenericAlias
from types import MappingProxyType
from types import ModuleType
from types import SimpleNamespace as Simple
from types import TracebackType
from typing import _alias
from typing import Any
from typing import AnyStr
from typing import ByteString
from typing import Callable
from typing import ChainMap
from typing import ClassVar
from typing import Generator
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import KeysView
from typing import Literal
from typing import MutableMapping
from typing import MutableSequence
from typing import MutableSet
from typing import NamedTuple
from typing import NoReturn
from typing import Optional
from typing import OrderedDict
from typing import overload
from typing import Protocol
from typing import runtime_checkable
from typing import Sequence
from typing import Sized
from typing import Type
from typing import TypeVar
from typing import Union
from typing import ValuesView

from box import Box
from bson import ObjectId
from click.exceptions import Exit as Exit
from decorator import decorator
from devtools import Debug
from dpath.util import delete as dpathdelete
from dpath.util import get as dpathget
from dpath.util import new as dpathnew
from dpath.util import set as dpathset
from dpath.util import search as dpathsearch
from dpath.util import values as dpathvalues
from environs import Env as Environs
from git import GitConfigParser
from git import Remote
from git import Repo as GitRepo
from git.refs import SymbolicReference as GitSymbolicReference
from icecream import IceCreamDebugger
from more_itertools import bucket
from rich.console import Console as Console
from rich.pretty import install as pretty_install
from rich.traceback import install as traceback_install
# </editor-fold>
# <editor-fold desc="TypeVars">
_A = TypeVar('_A', bound='Annotation')
_At = TypeVar('_At', bound='Attr')
_C = TypeVar('_C', bound='ChainRV')
_E = TypeVar('_E', bound='Executor')
_K = TypeVar('_K', bound='Kind')
_M = TypeVar('_M', bound='Mro')
_N = TypeVar('_N', bound='Name')
_T = TypeVar('_T')
_U = TypeVar('_U')
_KT = TypeVar("_KT")  # Key type.
_VT = TypeVar("_VT")  # Value type.
_T_co = TypeVar("_T_co", covariant=True)  # Any type covariant containers.

Bool = bool
Tuple = tuple
# </editor-fold>
# <editor-fold desc="Constants">
__all__: tuple
Alias = _alias
BUILTINS: dict
BUILTINS_CLASSES: tuple[Type, ...]
BUILTINS_FUNCTIONS: tuple[Union[BuiltinFunctionType, FunctionType], ...]
BUILTINS_OTHER: tuple[Any, ...]
CRLock = _CRLock
console: Console
DATACLASS_FIELDS: str
debug: Debug
fmic: IceCreamDebugger().format
fmicc: IceCreamDebugger().format
FRAME_SYS_INIT: FrameType
FUNCTION_MODULE: str
ic: IceCreamDebugger
icc: IceCreamDebugger
IgnoreAttr = Literal['asdict', 'attrs', 'defaults', 'keys', 'kwargs', 'kwargs_dict', 'public', 'values', 'values_dict']
IgnoreCopy = Union[CRLock, Environs, FrameType, GitConfigParser, GitSymbolicReference, Remote]
IgnoreStr = Union[GitConfigParser, GitRepo, ObjectId, PathLib]
LST = Union[MutableSequence, MutableSet, tuple]
MISSING_TYPE = _MISSING_TYPE
NEWLINE: str
POST_INIT_NAME: str
pp: console.print
print_exception: console.print_exception
PYTHON_SYS: str
PYTHON_SITE: pathlib.Path
RunningLoop = _RunningLoop
SeqNoStr = Union[Iterator, KeysView, MutableSequence, MutableSet, tuple, ValuesView]
SeqUnion = Union[AnyStr, ByteString, Iterator, KeysView, MutableSequence, MutableSet, Sequence, tuple, ValuesView]
# </editor-fold>
# <editor-fold desc="Exceptions">
class CmdError(Exception):
    def __init__(self, rv: CompletedProcess) -> None: ...
class CmdAioError(CmdError):
    def __init__(self, rv: CompletedProcess) -> None: ...
# </editor-fold>
# <editor-fold desc="Types">
class AnnotationsType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class AsDictMethodType(metaclass=ABCMeta):
    @abstractmethod
    def asdict(self, *args: Any, **kwargs: Any) -> dict[str, Any]: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class AsDictPropertyType(metaclass=ABCMeta):
    @property
    @abstractmethod
    def asdict(self) -> dict[str, Any]: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class DataType(metaclass=ABCMeta):
    __annotations__: MappingProxyType
    __dataclass_fields__: dict[str, Field]
    def __repr__(self) -> str: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class DictType(metaclass=ABCMeta):
    __dict__: MappingProxyType
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class GetAttrNoBuiltinType(metaclass=ABCMeta):
    def __getattribute__(self, name: str) -> Any: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class GetAttrType(metaclass=ABCMeta):
    def __getattribute__(self, name: str) -> Any: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
@runtime_checkable
class GetSupportType(Protocol):
    __slots__: tuple
    @abstractmethod
    def get(self, name: str, default: Any = ...) -> Any: ...
@runtime_checkable
class GetType(Protocol):
    def get(self, name: str, default: Any = ...) -> Any:
        pass
class NamedType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    def _asdict(self) -> dict[str, Any]: ...
    _fields: tuple
    _field_defaults: dict
class NamedAnnotationsType(metaclass=ABCMeta):
    __annotations__: MappingProxyType
    _fields: tuple[str]
    _field_defaults: MappingProxyType
    def _asdict(self) -> dict[str, Any]: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class SlotsType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
Types = Union[Type[AnnotationsType], Type[AsDictMethodType], Type[AsDictPropertyType],
              Type[DataType], Type[DictType], Type[GetAttrType],
              Type[GetAttrNoBuiltinType], Type[GetType], Type[NamedType], Type[NamedAnnotationsType],
              Type[SlotsType], Type[type]]
# </editor-fold>
# <editor-fold desc="Enums">
class Attr(Enum, Generic[_At]):
    ALL: _At
    PRIVATE: _At
    PUBLIC: _At
    def include(self, obj: str) -> bool: ...
class ChainRV(Enum):
    ALL: _C
    FIRST: _C
    UNIQUE: _C
class EnumDict(Enum):
    @classmethod
    def asdict(cls) -> dict: ...
    @classmethod
    def attrs(cls) -> list: ...
    @classmethod
    def default(cls) -> Any: ...
    @classmethod
    def default_attr(cls) -> str: ...
    @classmethod
    def default_dict(cls) -> dict: ...
    @classmethod
    def default_value(cls) -> Any: ...
    @property
    def describe(self) -> tuple: ...
    @property
    def lower(self) -> str: ...
    def prefix(self, prefix: str) -> str: ...
    @classmethod
    def values(cls) -> list: ...
EnumDictAlias: Alias
class Executor(Enum, Generic[_E]):
    PROCESS: _E
    THREAD: _E
    NONE: _E
    async def run(self, func: Any, *args: Any, **kwargs: Any) -> Any: ...
class Kind(Enum, Generic[_K]):
    CLASS: _K
    DATA: _K
    METHOD: _K
    PROPERTY: _K
    STATIC: _K
class _Mro(Enum):
    def _generate_next_value_(self: str, start: Any, count: Any, last_values: Any) -> str: ...
class Mro(_Mro, Generic[_M]):
    _asdict: _M
    _field_defaults : _M
    _fields: _M
    all: _M
    annotations: _M
    args: _M
    asdict: _M
    cache_clear: _M
    cache_info: _M
    cached: _M
    code: _M
    contains: _M
    dataclass_fields: _M
    dataclass_params: _M
    delattr: _M
    dict: _M
    dir: _M
    doc: _M
    eq: _M
    file: _M
    get: _M
    getattribute: _M
    getitem: _M
    hash_exclude: _M
    ignore_attr: _M
    ignore_copy: _M
    ignore_kwarg: _M
    ignore_str: _M
    init_subclass: _M
    len: _M
    loader: _M
    module: _M
    name: _M
    package: _M
    post_init: _M
    qualname: _M
    reduce: _M
    repr: _M
    repr_exclude: _M
    repr_newline: _M
    repr_pproperty: _M
    setattr: _M
    slots: _M
    spec: _M
    str: _M
    subclasshook: _M
    @classmethod
    @functools.cache
    def attrs(cls) -> tuple[str, ...]: ...
    @classmethod
    def cls(cls, obj: Any) -> tuple[Type, ...]: ...
    @property
    def default(self) -> tuple[str, ...]: ...
    def first(self, obj: Any) -> Any: ...
    def _firstdict(self, mro: Union[tuple[Type, ...], list[Type, ...]]) -> Any: ...
    def firstdict(self, obj: Any) -> Any: ...
    def firstdict_object(self, obj: Any) -> Any: ...
    @property
    def getter(self) -> getter: ...
    def has(self, obj: Any) -> bool: ...
    @classmethod
    @functools.cache
    def members(cls) -> dict[str, str]: ...
    @classmethod
    def obj(cls, obj: Any) -> tuple[Type, ...]: ...
    @classmethod
    def slot(cls, obj: Any, name: str) -> bool: ...
    def slotsinclude(self, obj: Any) -> set[str]: ...
    def val(self, obj: Any) -> set[Union[str, Type], ...]: ...
class Name(Enum, Generic[_N]):
    _all0: _N
    _class0: _N
    _annotations0: _N
    _builtins0: _N
    _cached0: _N
    _code0: _N
    _contains0: _N
    _dataclass_fields0: _N
    _dataclass_params0: _N
    _delattr0: _N
    _dict0: _N
    _dir0: _N
    _doc0: _N
    _eq0: _N
    _file0: _N
    _getattribute0: _N
    _len0: _N
    _loader0: _N
    _members0: _N
    _module0: _N
    _mro0: _N
    _name0: _N
    _package0: _N
    _qualname0: _N
    _reduce0: _N
    _repr0: _N
    _setattr0: _N
    _slots0: _N
    _spec0: _N
    _str0: _N
    _asdict: _N
    add: _N
    append: _N
    asdict: _N
    cls_: _N
    clear: _N
    co_name: _N
    code_context: _N
    copy: _N
    count: _N
    data: _N
    endswith: _N
    extend: _N
    external: _N
    f_back: _N
    f_code: _N
    f_globals: _N
    f_lineno: _N
    f_locals: _N
    filename: _N
    frame: _N
    function: _N
    get_: _N
    globals: _N
    index: _N
    item: _N
    items: _N
    keys: _N
    kind: _N
    lineno: _N
    locals: _N
    name_: _N
    origin: _N
    obj: _N
    object: _N
    REPO: _N
    pop: _N
    popitem: _N
    PYPI: _N
    remove: _N
    reverse: _N
    self_: _N
    sort: _N
    startswith: _N
    tb_frame: _N
    tb_lineno: _N
    tb_next: _N
    update: _N
    value_: _N
    values: _N
    vars: _N
    @classmethod
    @functools.cache
    def _attrs(cls) -> dict[bool, Iterable]: ...
    @classmethod
    @functools.cache
    def attrs(cls) -> tuple: ...
    @singledispatchmethod
    def get(self, obj: Any, default: Any = ...) -> Any: ...
    @get.register
    def get_getattrtype(self, obj: GetAttrType, default: Any = ...) -> Any: ...
    @get.register
    def get_frameinfo(self, obj: FrameInfo, default: Any = ...) -> Any: ...
    @get.register
    def get_frametype(self, obj: FrameType, default: Any = ...) -> Any: ...
    @get.register
    def get_tracebacktype(self, obj: TracebackType, default: Any = ...) -> Any: ...
    @property
    def getter(self) -> attrgetter: ...
    def has(self, obj: Any) -> bool: ...
    @classmethod
    def node(cls, obj: Any, complete: bool = ..., line: bool = ...) -> Union[tuple[AST, int], AST]: ...
    @classmethod
    def path(cls, obj: Any) -> PathLib: ...
    @classmethod
    @functools.cache
    def private(cls) -> tuple: ...
    @classmethod
    @functools.cache
    def public(cls) -> tuple: ...
    @classmethod
    @functools.cache
    def _real(cls, name: str) -> str: ...
    @property
    def real(self) -> str: ...
    @classmethod
    def _source(cls, obj: Any, line: bool = ...) -> Optional[Union[tuple[str, int], str]]: ...
    @classmethod
    def source(cls, obj: Any, complete: bool = ..., line: bool = ...) -> Union[tuple[str, int], str]: ...
# </editor-fold>
# <editor-fold desc="Bases">
class BoxKeys(Box[str, Any]):
    def __init__(self, keys: Iterable,
                 value: Optional[Union[Type, Literal['lower']]] = ...) -> None: ...
class Chain(ChainMap):
    rv: ChainRV
    default: Any
    maps: list[Union[Iterable, NamedType, MutableMapping]]
    def __init__(self, *maps: ..., rv: ChainRV = ..., default: Any = ...) -> None: ...
    def __getitem__(self, key: str) -> Any: ...
    def __delitem__(self, key: str) -> None: ...
    def delete(self, key: str) -> None: ...
    def __setitem__(self, key: str, value: Any) -> None: ...
    def set(self, key: str, value: Any) -> None: ...
class Es:
    __slots__: Tuple[str] = ...
    data: Any = ...
    def __init__(self, data: Any = ...) -> None: ...
    def __call__(self, *args: Type) -> Bool: ...
    def __getstate__(self) -> dict[str, Any]: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: dict[str, Any]): ...
    def __str__(self) -> str: ...
    def __class_getitem__(cls, item: Any) -> GenericAlias: ...
    @property
    def _func(self) -> Any: ...
    @property
    def annotation(self) -> Bool: ...
    @property
    def annotationstype(self) -> Bool: ...
    @property
    def annotationstype_sub(self) -> Bool: ...
    @property
    def asdict(self) -> dict[str, Any]: ...
    @property
    def asdictmethod(self) -> Bool: ...
    @property
    def asdictmethod_sub(self) -> Bool: ...
    @property
    def asdictproperty(self) -> Bool: ...
    @property
    def asdictproperty_sub(self) -> Bool: ...
    @property
    def ast(self) -> Bool: ...
    @property
    def asyncfor(self) -> Bool: ...
    @property
    def asyncfunctiondef(self) -> Bool: ...
    @property
    def asyncgen(self) -> Bool: ...
    @property
    def asyncgenfunction(self) -> Bool: ...
    @property
    def asyncwith(self) -> Bool: ...
    @property
    def attribute(self) -> Bool: ...
    @property
    def await_ast(self) -> Bool: ...
    @property
    def awaitable(self) -> Bool: ...
    @property
    def bool(self) -> Bool: ...
    @property
    def builtin(self) -> Bool: ...
    @property
    def builtinclass(self) -> Bool: ...
    @property
    def builtinfunction(self) -> Bool: ...
    @property
    def builtinfunctiontype(self) -> Bool: ...
    @property
    def bytesio(self) -> Bool: ...
    @property
    def cache(self) -> Bool: ...
    @property
    def cached_property(self) -> Bool: ...
    @property
    def callable(self) -> Bool: ...
    @property
    def chain(self) -> Bool: ...
    @property
    def chainmap(self) -> Bool: ...
    @property
    def classdef(self) -> Bool: ...
    @property
    def classmethod(self) -> Bool: ...
    @property
    def classmethoddescriptortype(self) -> Bool: ...
    @property
    def classvar(self) -> Bool: ...
    @property
    def codetype(self) -> Bool: ...
    @property
    def collections(self) -> Bool: ...
    @property
    def container(self) -> Bool: ...
    @property
    def coro(self) -> Bool: ...
    @property
    def coroutine(self) -> Bool: ...
    @property
    def coroutinefunction(self) -> Bool: ...
    @property
    def datafactory(self) -> Bool: ...
    @property
    def datafield(self) -> Bool: ...
    @property
    def datatype(self) -> Bool: ...
    @property
    def datatype_sub(self) -> Bool: ...
    @property
    def defaultdict(self) -> Bool: ...
    @property
    def deleter(self) -> Bool: ...
    @property
    def dict(self) -> Bool: ...
    @property
    def dicttype(self) -> Bool: ...
    @property
    def dicttype_sub(self) -> Bool: ...
    @property
    def dynamicclassattribute(self) -> Bool: ...
    @property
    def dlst(self) -> Bool: ...
    @property
    def enum(self) -> Bool: ...
    @property
    def enum_sub(self) -> Bool: ...
    @property
    def enumdict(self) -> Bool: ...
    @property
    def enumdict_sub(self) -> Bool: ...
    @property
    def even(self) -> Bool: ...
    @property
    def float(self) -> Bool: ...
    @property
    def fileio(self) -> Bool: ...
    @property
    def frameinfo(self) -> Bool: ...
    @property
    def frametype(self) -> Bool: ...
    @property
    def functiondef(self) -> Bool: ...
    @property
    def functiontype(self) -> Bool: ...
    @property
    def generator(self) -> Bool: ...
    @property
    def generatortype(self) -> Bool: ...
    @property
    def genericalias(self) -> Bool: ...
    @property
    def getattrnobuiltintype(self) -> Bool: ...
    @property
    def getattrnobuiltintype_sub(self) -> Bool: ...
    @property
    def getattrtype(self) -> Bool: ...
    @property
    def getattrtype_sub(self) -> Bool: ...
    @property
    def getsetdescriptor(self) -> Bool: ...
    @property
    def getsetdescriptortype(self) -> Bool: ...
    @property
    def gettype(self) -> Bool: ...
    @property
    def gettype_sub(self) -> Bool: ...
    @property
    def hashable(self) -> Bool: ...
    @property
    def import_ast(self) -> Bool: ...
    @property
    def importfrom(self) -> Bool: ...
    @property
    def initvar(self) -> Bool: ...
    @property
    def installed(self) -> Bool: ...
    def instance(self, *args: Type) -> Bool: ...
    @property
    def int(self) -> Bool: ...
    @property
    def io(self) -> Bool: ...
    @property
    def iterable(self) -> Bool: ...
    @property
    def iterator(self) -> Bool: ...
    @property
    def lambdatype(self) -> Bool: ...
    @property
    def list(self) -> Bool: ...
    @property
    def lst(self) -> Bool: ...
    @property
    def mappingproxytype(self) -> Bool: ...
    @property
    def mappingproxytype_sub(self) -> Bool: ...
    @property
    def memberdescriptor(self) -> Bool: ...
    @property
    def memberdescriptortype(self) -> Bool: ...
    @property
    def method(self) -> Bool: ...
    @property
    def methoddescriptor(self) -> Bool: ...
    @property
    def methoddescriptortype(self) -> Bool: ...
    @property
    def methodtype(self) -> Bool: ...
    @property
    def methodwrappertype(self) -> Bool: ...
    @property
    def methodwrappertype_sub(self) -> Bool: ...
    @property
    def missing(self) -> Bool: ...
    @property
    def mlst(self) -> Bool: ...
    @property
    def mm(self) -> Bool: ...
    @property
    def moduletype(self) -> Bool: ...
    @property
    def module_function(self) -> Bool: ...
    @property
    def noncomplex(self) -> Bool: ...
    @property
    def namedtype(self) -> Bool: ...
    @property
    def namedtype_sub(self) -> Bool: ...
    @property
    def named_annotationstype(self) -> Bool: ...
    @property
    def named_annotationstype_sub(self) -> Bool: ...
    @property
    def none(self) -> Bool: ...
    @property
    def object(self) -> Bool: ...
    @property
    def pathlib(self) -> Bool: ...
    def picklable(self, name: str) -> Bool: ...
    @property
    def primitive(self) -> Bool: ...
    @property
    def pproperty(self) -> Bool: ...
    @property
    def prop(self) -> Bool: ...
    @property
    def property_any(self) -> Bool: ...
    @property
    def reducible(self) -> Bool: ...
    @property
    def reducible_sequence_subclass(self) -> Bool: ...
    @property
    def routine(self) -> Bool: ...
    @property
    def sequence(self) -> Bool: ...
    @property
    def sequence_subclass(self) -> Bool: ...
    @property
    def set(self) -> Bool: ...
    @property
    def setter(self) -> Bool: ...
    @property
    def simple(self) -> Bool: ...
    @property
    def sized(self) -> Bool: ...
    @property
    def slotstype(self) -> Bool: ...
    @property
    def slotstype_sub(self) -> Bool: ...
    @property
    def staticmethod(self) -> Bool: ...
    @property
    def str(self) -> Bool: ...
    @property
    def subclass(self) -> Bool: ...
    @property
    def stringio(self) -> Bool: ...
    @property
    def tracebacktype(self) -> Bool: ...
    @property
    def tuple(self) -> Bool: ...
    @property
    def type(self) -> Bool: ...
    @property
    def unicode(self) -> Bool: ...
    @property
    def wrapperdescriptortype(self) -> Bool: ...
class pproperty(property):
    def __init__(self, fget: Callable = ..., fset: Callable = ..., fdel: Callable = ..., doc: str = ...) -> None: ...


# </editor-fold>
# <editor-fold desc="Functions">
def aioloop() -> Optional[RunningLoop]: ...
def allin(origin: Iterable, destination: Iterable) -> bool: ...
def annotations(obj: Any, stack: Union[FrameType, int] = ...) -> Union[dict[str, Annotation], dict]: ...
def annotations_init(cls: Type[Union[NamedAnnotationsType, NamedTuple]], stack: Union[FrameType, int] = ...,
                     optional: bool = ..., **kwargs) -> NamedTuple: ...
def anyin(origin: Iterable, destination: Iterable) -> Optional[Any]: ...
@singledispatch
def asdict(data: Union[Semaphore, Enum, Chain, Environs, GitSymbolicReference, IgnoreStr,
                       Logger, MutableMapping, NamedType, Remote],
           convert: bool = ...) -> Union[MappingProxyType, Semaphore]: ...
@asdict.register
def asdict_chain(data: Chain, convert: bool = ...) -> Union[MappingProxyType, Chain]: ...
@asdict.register
def asdict_enum(data: Enum, convert: bool = ...) -> Union[MappingProxyType, Enum]: ...
@asdict.register
def asdict_environs(data: Environs, convert: bool = ...) -> Union[MappingProxyType, Environs]: ...
@asdict.register
def asdict_gettype(data: GetType, convert: bool = ...) -> Union[MappingProxyType, GetType]: ...
@asdict.register
def asdict_gitsymbolic(data: GitSymbolicReference, convert: bool = ...
                       ) -> Union[MappingProxyType, GitSymbolicReference]: ...
@asdict.register
def asdict_logger(data: Logger, convert: bool = ...) -> Union[MappingProxyType, Logger]: ...
@asdict.register
def asdict_namedtype(data: NamedType, convert: bool = ...) -> Union[MappingProxyType, NamedType]: ...
@asdict.register
def asdict_remote(data: Remote, convert: bool = ...) -> Union[MappingProxyType, Remote]: ...
def asdict_ignorestr(data: IgnoreStr, convert: bool = ...) -> Union[str, IgnoreStr]: ...
def asdict_props(data: Any, key: Attr = ..., pprop: bool = ...) -> dict[str, Any]: ...
def asdict_type(data: Type[Enum], convert: bool =  ...) -> Type[Enum]: ...
def classify_cls(data: Any) -> dict[str, Attribute]: ...
def clsinfo(data: Any) -> ClsInfo: ...
def clsitem(data: Any) -> dict[str, ClsItem]: ...
def cmd(command: Iterable,
        exc: bool = ...,
        lines: bool = ...,
        shell: bool = ...,
        py: bool = ...,
        pysite: bool = ...) -> Union[CompletedProcess, int, list, str]: ...
def cmdname(func: Callable, sep: str = ...) -> str: ...
def current_task_name() -> str: ...
@singledispatch
def delete(data: Union[MutableMapping, list], key: Iterable = ...) -> Optional[dict]: ...
@delete.register
def delete_list(data: list, key: Iterable = ...) -> Optional[list]: ...
def dict_sort(data: dict, ordered: bool = ..., reverse: bool = ...) -> Union[dict, OrderedDict]:...
def effect(apply: Callable, data: Iterable) -> NoReturn:...
@singledispatch
def get(data: Any, name: str, default: Any = ...) -> Any: ...
@get.register
def get_getattrtype(data: GetAttrType, name: str, default: Any = ...) -> Any: ...
def getset(data: Any, name: str, default: Any = ...) -> Any: ...
def iseven(number: int) -> bool: ...
def in_dict(data: MutableMapping, items: Optional[dict] = ..., **kwargs: Any) -> bool: ...
def join_newline(data: Iterable[str]) -> str: ...
def map_reduce_even(iterable: Iterable[_T]) -> list[_U, list[_T]]:...
def map_with_args(data: Any, func: Callable, /, *args, pred: Callable = lambda x: True if x else False,
                  split: str = ' ', **kwargs) -> list: ...
def newprop(name: str = ..., default: Optional[Any, Callable, partial] = ...,
            pprop: bool = ...) -> Union[property, pproperty]: ...
def noexception(
        exception: Union[tuple[Type[Exception]], Type[Exception]],
        func: Callable,
        *args,
        default_: Any = ...,
        **kwargs
) -> Any: ...
def prefixed(name: str) -> str: ...
def repr_format(obj: Any, attrs: Iterable[str], clear: bool = ..., newline: bool = ...) -> str: ...
@decorator
def runwarning(func: Callable, *args: Any, **kwargs: Any) -> Any: ...
def split_sep(sep: str = ...) -> dict: ...
def startswith(name: str, builtin: bool = ...) -> bool: ...
def to_camel(text: str, replace: bool = True) -> str: ...
def to_iter(data: Any, split: str = ...) -> Union[Sized, MutableMapping, Sequence, MutableSequence]: ...
def token_open(file: Union[PathLike, PathLib, str]) -> str: ...
def varname(index: int = ..., lower: bool = ..., sep: str = ...) -> Optional[str]: ...
def yield_if(data: Any, pred: Callable = ..., split: str = ...,
             apply: Union[Callable, tuple[Callable, ...]] = ...) -> Generator: ...
def yield_last(data: Any) -> Iterator[tuple[bool, Any, Optional[Any, None]]]: ...
# </editor-fold>
# <editor-fold desc="Meta">
class ClsMeta(type):
    clsinfo: ClsInfo
    clsitem: dict[str, ClsItem]
    @overload
    def __new__(mcs, o: object) -> type: ...
    @overload
    def __new__(mcs, name: str, bases: tuple[type, ...], namespace: dict[str, Any]) -> type: ...
    def __class_getitem__(mcs, item: str) -> Union[Any, NotImplemented]: ...
class Class(metaclass=ClsMeta):
    __slots__: tuple[str, ...] = ...
# </editor-fold>
# <editor-fold desc="Classes">
class AsDict:
    """
    Dict and Attributes Class.

    Examples:

        .. code-block:: python

            json = jsonpickle.encode(col)
            obj = jsonpickle.decode(obj)
            col.to_file(name=col.col_name)
            assert (Path.cwd() / f'{col.col_name}.json').is_file()
            col.to_file(directory=tmpdir, name=col.col_name, regenerate=True)
            obj = col.from_file(directory=tmpdir, name=col.col_name)
            assert obj == col
    """
    __ignore_attr__: list = ...
    @property
    def asdict(self) -> dict: ...
    @property
    def attrs(self) -> list: ...
    def attrs_get(self, *args: Any, default: Any = ...) -> dict: ...
    def attrs_set(self, *args: Any, **kwargs: Any) -> None: ...
    @classmethod
    def defaults(cls, nested: bool = ...) -> dict: ...
    def from_file(self, directory: Any =..., name: str = ..., keys: bool = ...): ...
    @property
    def keys(self) -> list: ...
    @property
    def kwargs(self) -> dict: ...
    @property
    def kwargs_dict(self) -> dict: ...
    @property
    def public(self) -> dict: ...
    def to_file(self, directory: Any = ..., name: str = ..., regenerate: bool = ..., **kwargs: Any) -> None: ...
    def to_json(self, regenerate: bool = ..., indent: bool = ..., keys: bool = ...,
                max_depth: int = ...) -> JSONEncoder: ...
    def to_obj(self, keys: bool = True): ...
    @property
    def values(self) -> list: ...
    @property
    def values_dict(self) -> list: ...
class Base:
    __slots__: tuple[str] = ...
    __hash_exclude__: tuple[str] = ...
    __ignore_attr__: tuple[str] = ...
    __ignore_copy__: tuple[Type, ...] = ...
    __ignore_kwarg__: tuple[str] = ...
    __ignore_str__: tuple[Type, ...] = ...
    __repr_exclude__: tuple[str] = ...
    __repr_newline__: bool = ...
    __repr_pproperty__: bool = ...
    def __getattribute__(self, name: str, default: Any = ...) -> Any: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def get(self, name: str, default: Union[Any, partial] = ...) -> Any: ...
    def _info(self,
             depth: Optional[int] = ...,
             ignore: bool = ...,
             key: Attr = ...) -> info: ...
    @property
    def info(self) -> info: ...
class Cls:
    __slots__: tuple[str] = ...
    args: dict[str, Any]
    asdict: dict[str, Any]
    attr: Es
    builtin: bool
    cache: dict[str, Attribute]
    cached_property: dict[str, Attribute]
    classified: dict[str, Attribute]
    classmethod: dict[str, Attribute]
    classvar: dict[str, Union[Field, ClassVar]]
    coro: list[str]
    data: Types
    defaults: dict[str, Any]
    dir: list[str]
    dynamicclassattribute: dict[str, DynamicClassAttribute]
    es: Es
    factory: dict[str, Any]
    fields: dict[str, Field]
    ignore: bool
    initvar: dict[str, Field]
    key: Attr
    kwargs: dict[str, Any]
    method: dict[str, Attribute]
    mro: tuple[Type, ...]
    name: str
    pproperty: dict[str, Attribute]
    prop: dict[str, Attribute]
    property_any: dict[str, Attribute]
    slots: list[str]
    staticmethod: dict[str, Attribute]
    def __init__(self, data: Any, ignore: bool = ..., key: Attr = ...) -> None:...
    def __call__(self, ignore: bool = ..., key: Attr = ...) -> Cls:...
    @functools.cache
    def annotations(self, stack: Union[FrameType, int] = ...) -> dict[str, Annotation]:...
    @property
    def _asyncgen(self) -> dict[str, Any]:...
    @property
    def _asyncgenfunc(self) -> dict[str, Any]:...
    @functools.cache
    def _attr_value(self, name: str, default: Any = ...) -> dict[str, Attribute]:...
    @property
    def _awaitable(self) -> dict[str, Any]:...
    @property
    def _builtinclass(self) -> dict[str, Any]:...
    @property
    def _builtinfunctiontype(self) -> dict[str, Any]:...
    @property
    def _by_kind(self) -> bucket[defaultdict[str, deque[Attribute]]]: ...
    @property
    def _by_name(self) -> bucket[defaultdict[str, deque[Attribute]]]: ...
    @property
    def _cache(self) -> dict[str, Any]:...
    @property
    def _cached_property(self) -> dict[str, Any]:...
    @property
    def _callable(self) -> dict[str, Any]: ...
    @property
    def _classmethod(self) -> dict[str, Any]: ...
    @property
    def _coro(self) -> dict[str, Any]: ...
    @property
    def _coroutine(self) -> dict[str, Any]: ...
    @property
    def _coroutinefunc(self) -> dict[str, Any]: ...
    @property
    def _data_attrs(self) -> list[str]: ...
    @property
    def _defaults(self) -> list[str]: ...
    @property
    def _deleter(self) -> dict[str, Any]: ...
    @property
    def _dir(self) -> list[str]: ...
    @functools.cache
    def has_attr(self, name: str) -> bool: ...
    @functools.cache
    def has_method(self, name: str) -> bool: ...
    @property
    def has_reduce(self) -> bool: ...
    @property
    def importable_name(self) -> str: ...
    @functools.cache
    def is_attr(self, name: str) -> bool: ...
    @functools.cache
    def is_callable(self, name: str) -> bool: ...
    @functools.cache
    def is_classmethod(self, name: str) -> bool: ...
    @functools.cache
    def is_classvar(self, name: str) -> bool:...
    @functools.cache
    def is_data(self, name: str) -> bool: ...
    @functools.cache
    def is_deleter(self, name: str) -> bool: ...
    @functools.cache
    def is_datafactory(self, name: str) -> bool:...
    @functools.cache
    def is_datafield(self, name: str) -> bool:...
    @functools.cache
    def is_initvar(self, name: str) -> bool:...
    @functools.cache
    def is_memberdescriptor(self, name: str) -> bool: ...
    @functools.cache
    def is_method(self, name: str) -> bool: ...
    @functools.cache
    def is_methoddescriptor(self, name: str) -> bool: ...
    @functools.cache
    def is_pproperty(self, name: str) -> bool: ...
    @functools.cache
    def is_property(self, name: str) -> bool: ...
    @functools.cache
    def is_routine(self, name: str) -> bool: ...
    @functools.cache
    def is_setter(self, name: str) -> bool: ...
    @functools.cache
    def is_staticmethod(self, name: str) -> bool: ...
    @property
    def _mappingproxytype(self) -> dict[str, Any]: ...
    @property
    def _memberdescriptor(self) -> dict[str, Any]: ...
    @property
    def _method(self) -> dict[str, Any]: ...
    @property
    def _methoddescriptor(self) -> dict[str, Any]: ...
    @property
    def _methodwrappertype(self) -> dict[str, Any]: ...
    @property
    def _modname(self) -> str: ...
    @property
    def _mro(self) -> tuple[Type]: ...
    @property
    def _name(self) -> str: ...
    @property
    def _pproperty(self) -> dict[str, Any]: ...
    @property
    def _prop(self) -> dict[str, Any]: ...
    @property
    def _property_any(self) -> dict[str, Any]: ...
    @property
    def _qualname(self) -> str: ...
    @property
    def _routine(self) -> dict[str, Any]: ...
    @property
    def _setter(self) -> dict[str, Any]: ...
    @property
    def _staticmethod(self) -> dict[str, Any]: ...
class info:
    __slots__: tuple[str] = ...
    __ignore_attr__: tuple[str] = ...
    __ignore_copy__: tuple[Type, ...] = ...
    __ignore_kwarg__: tuple[str] = ...
    __ignore_str__: tuple[Type, ...] = ...
    _data: Any
    _depth: Optional[int]
    _ignore: bool
    _key: Attr
    def __init__(self,
                 data: Any,
                 depth: Optional[int] = ...,
                 ignore: bool = ...,
                 key: Attr = ...) -> None:...
    def __call__(self,
                 depth: Optional[int] = ...,
                 ignore: bool = ...,
                 key: Attr = ...) -> info:...
    def annotations(self, stack: Union[FrameType, int] = ...) -> Union[dict[str, Annotation]: ...]:...
    def asdict(self, count: int = ..., defaults: bool = ...) -> Any:...
    def attr_value(self, name: str, default: Any = ...):...
    @property
    def attrs(self) -> list[str]:...
    @property
    def attrs_cls(self) -> list[str]:...
    @property
    def cls(self) -> Cls:...
    @property
    def coros(self) -> list[str]:...
    @property
    def coros_pproperty(self) -> list[str]:...
    @property
    def coros_property(self) -> list[str]:...
    @property
    def data(self) -> Type:...
    @data.setter
    def data(self, value: Any) -> None:...
    @data.deleter
    def data(self) -> None:...
    @property
    def defaults(self) -> dict[str, Any]: ...
    @property
    def depth(self) -> Optional[int]:...
    @depth.setter
    def depth(self, value: Optional[int]) -> None:...
    @depth.deleter
    def depth(self) -> None:...
    @property
    def dir(self) -> set[str]:...
    def es(self, data: Any = ...) -> Es:...
    def has_attr(self, name: str) -> bool:...
    def has_method(self, name: str) -> bool:...
    @property
    def has_reduce(self) -> bool:...
    @property
    def hash(self) -> int:...
    @property
    def ignore(self) -> bool:...
    @ignore.setter
    def ignore(self, value: bool) -> None:...
    @ignore.deleter
    def ignore(self) -> None:...
    @property
    def ignore_attr(self):...
    def _include_attr(self, name: str, exclude: SeqUnion = ...) -> bool:...
    def _include_exclude(self, data: Any, key: bool = ...) -> bool:...
    def include(self, key: Any = ..., data: Any = ...) -> Optional[tuple]:...
    @property
    def initvarsdict(self) -> dict[str, Any]:...
    def is_attr(self, name: str) -> bool:...
    def is_coro(self, name: str) -> bool:...
    def is_coro_pproperty(self, name: str) -> bool:...
    def is_coro_property(self, name: str) -> bool:...
    @property
    def key(self) -> Attr:...
    @key.setter
    def key(self, value: Attr) -> None:...
    @key.deleter
    def key(self) -> None:...
    @property
    def keys(self) -> list[str]:...
    @property
    def kwargs(self) -> dict[str, Any]:...
    @property
    def kwargs_dict(self) -> dict[str, Any]:...
    @property
    def module(self) -> ModuleType:...
    @property
    def public(self) -> dict[str, Any]: ...
    @property
    def repr(self) -> str: ...
    def to_json(self, regenerate: bool = ..., indent: bool = ..., keys: bool = ...,
                max_depth: int = ...) -> JSONEncoder: ...
    def to_obj(self, keys: bool = ...) -> Any: ...
    @property
    def values(self) -> list: ...
    @property
    def values_dict(self) -> list: ...
    @property
    def vars(self) -> dict[str, Any]: ...
class Seq(Sequence):
    __slots__: tuple[str, ...] = ...
    @overload
    @abstractmethod
    def __getitem__(self, i: int) -> _T_co: ...
    @overload
    @abstractmethod
    def __getitem__(self, s: slice) -> Seq[_T_co]: ...
    @overload
    def first_anyin(self, *args: Any) -> Any: ...
    @overload
    def first_anyin(self, **kwargs: _VT) -> Any: ...
# </editor-fold>
# <editor-fold desc="NamedTuples">
Annotation = NamedTuple('Annotation', any=bool, args=list[Generic[_A], ...], classvar=bool, cls=Type, default=Any,
                        final=bool, hint=Type,
                        initvar=bool, literal=bool, name=str, optional=bool, origin=Any, union=bool)
Attribute = NamedTuple('Attribute', defining=type, es=Es, field=Es[Field], hint=Any, kind=Kind, name=str,
                       object=Any)
ClsInfo = NamedTuple('ClsInfo', builtin=Optional[Type], cls=Optional[Type], mro=Optional[tuple[Type, ...]],
                      name=Optional[str], qual=Optional[str], super=Optional[Type])
ClsItem = NamedTuple('ClsItem', defining=type, es=Es, field=Es[Field], hint=Any, kind=Kind, name=str,
                      object=Any)
# </editor-fold>
# <editor-fold desc="Echo">
def black(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def blue(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def cyan(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def green(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def magenta(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
            blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def red(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
        blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def white(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def yellow(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bblack(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bblue(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bcyan(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bgreen(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bmagenta(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
             blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bred(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bwhite(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def byellow(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
            blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
# </editor-fold>
# <editor-fold desc="Test">
class TestAsync:
    _async_classmethod: str = ...
    _classmethod: str = ...
    _async_method: str = ...
    _method: str = ...
    _async_cprop: str = ...
    _cprop: str = ...
    _async_pprop: str = ...
    _pprop: str = ...
    _async_prop: str = ...
    _prop: str = ...
    _async_staticmethod: str = ...
    _staticmethod: str = ...
    @classmethod
    async def async_classmethod(cls) -> str: ...
    @classmethod
    def classmethod(cls) -> str: ...
    async def async_method(self) -> str: ...
    def method(self) -> str: ...
    @property
    async def async_cprop(self) -> str: ...
    @property
    def cprop(self) -> str: ...
    @property
    async def async_pprop(self) -> str: ...
    @property
    def pprop(self) -> str: ...
    @property
    async def async_prop(self) -> str: ...
    @property
    def prop(self) -> str: ...
    @staticmethod
    async def async_staticmethod() -> str: ...
    @staticmethod
    def staticmethod() -> str: ...
class TestBase(Base):
    classvar: ClassVar[int] = ...
    initvar: InitVar[int] = ...
    __slots__: tuple[str] = ...
    __hash_exclude__: tuple[str] = ...
    __repr_exclude__: tuple[str] = ...
    async def method_async(self) -> NoReturn: ...
    @classmethod
    def clsmethod(cls) -> NoReturn: ...
    @staticmethod
    def static() -> NoReturn: ...
    @pproperty
    def pprop(self) -> str: ...
    @pproperty
    async def pprop_async(self) -> str: ...
    @property
    def prop(self) -> Any: ...
    @prop.setter
    def prop(self, value: Any) -> None: ...
    @prop.deleter
    def prop(self) -> None: ...
@dataclass
class TestData:
    dataclass_classvar: ClassVar[str] = ...
    dataclass_default: str = ...
    dataclass_default_factory: Union[dict, str] = ...
    dataclass_default_factory_init: Union[dict, str] = ...
    dataclass_default_init: str = ...
    dataclass_initvar: InitVar[str] = ...
    dataclass_str: str = ...
    def __post_init__(self, dataclass_initvar: str) -> None: ...
    def __class_getitem__(cls, item: Any) -> GenericAlias: ...
class TestDataDictMix(TestData):
    subclass_annotated_str: str = ...
    subclass_classvar: ClassVar[str] = ...
    subclass_str: str = ...
    def __init__(self, dataclass_initvar: str = ..., subclass_dynamic: str = ...,) -> None: ...
class TestDataDictSlotMix(TestDataDictMix):
    __slots__ = ('_slot_property', 'slot', )
    _slot_property: str
    slot: str
    def __init__(self, dataclass_initvar: str =  ..., slot_property: str =  ..., slot: str =  ...) -> None: ...
    @pproperty
    def slot_property(self) -> str: ...
# </editor-fold>
