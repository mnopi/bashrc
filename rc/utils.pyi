# -*- coding: utf-8 -*-
"""Utils Module."""
import pathlib
from abc import ABCMeta
from asyncio.events import _RunningLoop
from enum import Enum
from functools import cache
from functools import partial
from functools import singledispatch
from functools import singledispatchmethod
from inspect import Attribute
from inspect import FrameInfo
from operator import attrgetter
from subprocess import CompletedProcess
from types import FrameType
from types import ModuleType
from typing import _alias
from typing import Any
from typing import Callable
from typing import ChainMap
from typing import Iterable
from typing import MutableMapping
from typing import NamedTuple
from typing import NoReturn
from typing import Optional
from typing import OrderedDict
from typing import Type
from typing import TypeVar
from typing import Union

from box import Box
from devtools import Debug
from icecream import IceCreamDebugger
from rich import Console

_C = TypeVar('_C', bound='ChainRV')
_E = TypeVar('_E', bound='Executor')
_K = TypeVar('_K', bound='Key')
_N = TypeVar('_N', bound='Name')
_T = TypeVar('_T')
_U = TypeVar('_U')

__all__: tuple
NEWLINE: str
PYTHON_SYS: str
PYTHON_SITE: pathlib.Path
Alias = _alias
console: Console
debug: Debug
fmic: IceCreamDebugger().format
fmicc: IceCreamDebugger().format
ic: IceCreamDebugger
icc: IceCreamDebugger
pp: console.print
print_exception: console.print_exception
Annotation = NamedTuple('Annotation', args=list[Type, ...], cls=Type, hints=dict, key=str, origin=Type)
class AnnotationsType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class AsDictClassMethodType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    @classmethod
    def asdict(cls, *args: Any, **kwargs: Any) -> dict[str, Any]: ...
class AsDictMethodType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    def asdict(self, *args: Any, **kwargs: Any) -> dict[str, Any]: ...
class AsDictPropertyType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    @property
    def asdict(self) -> dict[str, Any]: ...
class AsDictStaticMethodType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    @staticmethod
    def asdict(*args: Any, **kwargs: Any) -> dict[str, Any]: ...
class Base:
    __slots__: tuple[str]
    __hash_exclude__: tuple[str]
    __repr_exclude__: tuple[str]
    def __getattribute__(self, name: str, default: Optional[Any, partial] = ...) -> Any: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def get(self, name: str, default: Union[Any, partial] = ...) -> Any: ...
    @property
    def get_clsname(self) -> str: ...
    @staticmethod
    def get_mroattr(cls: Type, name: str = ...) -> set[str]: ...
    @classmethod
    def get_mrohash(cls) -> set[str]: ...
    @classmethod
    def get_mrorepr(cls) -> list[str]: ...
    @classmethod
    def get_mroslots(cls) -> set[str]: ...
    @staticmethod
    def get_propnew(name: str, default: Optional[Any, partial] = ...) -> property: ...
class BoxKeys(Box[str, str]):
    def __init__(self, keys: Iterable, lower: bool = ...) -> None: ...
class ChainRV(Enum):
    ALL: _C
    FIRST: _C
    UNIQUE: _C
class Chain(ChainMap):
    rv: ChainRV
    default: Any
    maps: list[Union[Iterable, NamedType, MutableMapping]]
    def __init__(self, *maps: ..., rv: ChainRV = ..., default: Any = ...) -> None: ...
    def __getitem__(self, key: str) -> Any: ...
    def __delitem__(self, key: str) -> None: ...
    def delete(self, key: str) -> None: ...
    def __setitem__(self, key: str, value: Any) -> None: ...
    def set(self, key: str, value: Any) -> None: ...
class CmdError(Exception):
    def __init__(self, rv: CompletedProcess) -> None: ...
class CmdAioError(CmdError):
    def __init__(self, rv: CompletedProcess) -> None: ...
class DataType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class DictType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class EnumDict(Enum):
    @classmethod
    def asdict(cls) -> dict: ...
    @classmethod
    def attrs(cls) -> list: ...
    @classmethod
    def default(cls) -> Any: ...
    @classmethod
    def default_attr(cls) -> str: ...
    @classmethod
    def default_dict(cls) -> dict: ...
    @classmethod
    def default_value(cls) -> Any: ...
    @property
    def describe(self) -> tuple: ...
    @property
    def lower(self) -> str: ...
    def prefix(self, prefix: str) -> str: ...
    @classmethod
    def values(cls) -> list: ...
class Executor(Enum):
    PROCESS: _E
    THREAD: _E
    NONE: _E
    async def run(self, func: Any, *args: Any, **kwargs: Any) -> Any: ...
class GetType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    def get(self, name: str, default: Any = ...) -> bool: ...
class Key(Enum):
    ALL: _K
    PRIVATE: _K
    PUBLIC: _K
    def include(self, obj: str) -> bool: ...
class Name(Enum):
    __all: _N
    __class: _N
    __annotations: _N
    __builtins: _N
    __cached: _N
    __contains: _N
    __dataclass_fields: _N
    __dataclass_params: _N
    __delattr: _N
    __dir: _N
    __dict: _N
    __doc: _N
    __eq: _N
    __file: _N
    __getattribute: _N
    __hash_exclude: _N
    __ignore_attr: _N
    __ignore_str: _N
    __len: _N
    __loader: _N
    __members: _N
    __module: _N
    __mro: _N
    __name: _N
    __package: _N
    __qualname: _N
    __reduce: _N
    __repr: _N
    __repr_exclude: _N
    __setattr: _N
    __slots: _N
    __spec: _N
    __str: _N
    _asdict: _N
    add: _N
    append: _N
    asdict: _N
    cls_: _N
    clear: _N
    copy: _N
    count: _N
    data: _N
    endswith: _N
    extend: _N
    external: _N
    f_code: _N
    f_globals: _N
    f_locals: _N
    frame: _N
    function: _N
    get_: _N
    index: _N
    item: _N
    items: _N
    keys: _N
    kind: _N
    lineno: _N
    name_: _N
    origin: _N
    obj: _N
    object: _N
    REPO: _N
    pop: _N
    popitem: _N
    PYPI: _N
    remove: _N
    reverse: _N
    self_: _N
    sort: _N
    startswith: _N
    update: _N
    value_: _N
    values: _N
    @singledispatchmethod
    def get(self, obj: GetType, default: Any = ...) -> Any: ...
    @get.register
    def _(self, obj: FrameInfo, default: Any = ...) -> Any: ...
    @get.register
    def _(self, obj: FrameType, default: Any = ...) -> Any: ...
    @get.register
    def _(self, obj: DictType, default: Any = ...) -> Any: ...
    @property
    @cache
    def getter(self) -> attrgetter: ...
    def has(self, obj: Any) -> bool: ...
    @classmethod
    @cache
    def attrs(cls) -> dict: ...
    @classmethod
    @cache
    def private(cls) -> list: ...
    @classmethod
    @cache
    def public(cls) -> tuple: ...
    @classmethod
    @cache
    def _real(cls, name: str) -> str: ...
    @property
    def real(self) -> str: ...
class NamedType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    def _asdict(self) -> dict[str, Any]: ...
class NamedAnnotationsType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class SlotsType(metaclass=ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
def aioloop() -> Optional[_RunningLoop]: ...
def annotations(obj: Any, index: int = ...) -> Union[dict[str, Annotation]: ...]: ...
def cmd(command: Iterable,
        exc: bool = ...,
        lines: bool = ...,
        shell: bool = ...,
        py: bool = ...,
        pysite: bool = ...) -> Union[CompletedProcess, int, list, str]: ...
def cmdname(func: Callable, sep: str = ...) -> str: ...
def current_task_name() -> str: ...
@singledispatch
def delete(data, key: Iterable = ...) -> Optional[dict]: ...
@delete.register
def _(data, key: Iterable = ...) -> Optional[list]: ...
def dict_sort(data: dict, ordered: bool = ..., reverse: bool = ...) -> Union[dict, OrderedDict]:...
def get(obj: Any, name: str, d: Any = ...) -> Any: ...
class info:
    __slots__: tuple
    _data: Any
    _key: Key
    def __init__(self, data: Any = ..., key: Key = ...) -> None:...
    def __call__(self, data: Optional[Any] = ..., key: Optional[Key] = ...) -> info:...
    @property
    def data(self) -> Any:...
    @data.setter
    def data(self, v: Any) -> NoReturn:...
    @data.deleter
    def data(self) -> NoReturn:...
    @property
    def key(self) -> Key:...
    @key.setter
    def key(self, v: Key) -> NoReturn:...
    @key.deleter
    def key(self) -> NoReturn:...
    def get_callables(self, public: bool = ...) -> dict[str, Attribute]:...
    def get_classmethods(self, public: bool = ...) -> dict[str, Attribute]:...
    @property
    def get_cls(self) -> bool:...
    def get_clsattr(self, name: str, default: Any = ...) -> dict[str, Attribute]:...
    @property
    def get_clsmodule(self) -> bool:...
    @property
    def get_clsname(self) -> bool:...
    def get_properties(self, public: bool = ...) -> dict[str, Attribute]:...
    @property
    def get_clsqual(self) -> bool:...
    def get_dir(self, public: bool = ...) -> list[str]:...
    def get_dircls(self, public: bool = ...) -> list[str]:...
    def get_dirinstance(self, public: bool = ...) -> list[str]:...
    @property
    def get_inspect(self) -> Attribute:...
    def get_methods(self, public: bool = ...) -> dict[str, Attribute]:...
    @property
    def get_importable_name(self) -> str:...
    @property
    def get_module(self) -> ModuleType:...
    @property
    def get_mro(self) -> Attribute:...
    def get_mroattrins(self, name: str = ...) -> tuple[str]:...
    @property
    def get_staticmethods(self) -> dict[str, Attribute]:...
    @property
    def has_attr(self) -> bool:...
    @property
    def has_method(self) -> bool:...
    @property
    def has_reduce(self) -> bool:...
    def in_slot(self, name: str = ...) -> bool:...
    @property
    def is_annotations_type(self) -> bool:...
    @property
    def is_annotations_type_sub(self) -> bool:...
    @property
    def is_asdict_classmethod_type(self) -> bool:...
    @property
    def is_asdict_classmethod_type_sub(self) -> bool:...
    @property
    def is_asdict_method_type(self) -> bool:...
    @property
    def is_asdict_method_type_sub(self) -> bool:...
    @property
    def is_asdict_property_type(self) -> bool:...
    @property
    def is_asdict_property_type_sub(self) -> bool:...
    @property
    def is_asdict_staticmethod_type(self) -> bool:...
    @property
    def is_asdict_staticmethod_type_sub(self) -> bool:...
    @property
    def is_asyncgen(self) -> bool:...
    @property
    def is_asyncgenfunc(self) -> bool:...
    def is_attr(self, name: str) -> bool:...
    @property
    def is_awaitable(self) -> bool:...
    @property
    def is_bool(self) -> bool:...
    @property
    def is_chain(self) -> bool:...
    @property
    def is_chainmap(self) -> bool:...
    @property
    def is_classmethod(self) -> bool:...
    @property
    def is_collections(self) -> bool:...
    @property
    def is_coro(self) -> bool:...
    @property
    def is_coroutine(self) -> bool:...
    @property
    def is_coroutinefunc(self) -> bool:...
    @property
    def is_data_type(self) -> bool:...
    @property
    def is_data_type_sub(self) -> bool:...
    @property
    def is_defaultdict(self) -> bool:...
    @property
    def is_dict(self) -> bool:...
    @property
    def is_dict_type(self) -> bool:...
    @property
    def is_dict_type_sub(self) -> bool:...
    @property
    def is_dlst(self) -> bool:...
    @property
    def is_enum(self) -> bool:...
    @property
    def is_enum_sub(self) -> bool:...
    @property
    def is_enumdict(self) -> bool:...
    @property
    def is_enumdict_sub(self) -> bool:...
    @property
    def is_float(self) -> bool:...
    @property
    def is_generator(self) -> bool:...
    @property
    def is_get_type(self) -> bool:...
    @property
    def is_get_type_sub(self) -> bool:...
    @property
    def is_getsetdescriptor(self) -> bool:...
    @property
    def is_hashable(self) -> bool:...
    @property
    def is_installed(self) -> bool:...
    def is_instance(self, *args: Type) -> bool:...
    @property
    def is_int(self) -> bool:...
    @property
    def is_iterable(self) -> bool:...
    @property
    def is_iterator(self) -> bool:...
    @property
    def is_list(self) -> bool:...
    @property
    def is_lst(self) -> bool:...
    @property
    def is_mlst(self) -> bool:...
    @property
    def is_method(self) -> bool:...
    @property
    def is_module(self) -> bool:...
    @property
    def is_module_function(self) -> bool:...
    @property
    def is_noncomplex(self) -> bool:...
    @property
    def is_named_type(self) -> bool:...
    @property
    def is_named_type_sub(self) -> bool:...
    @property
    def is_named_annotations_type(self) -> bool:...
    @property
    def is_named_annotations_type_sub(self) -> bool:...
    @property
    def is_object(self) -> bool:...
    def is_picklable(self, name: str) -> bool:...
    @property
    def is_primitive(self) -> bool:...
    @property
    def is_property(self) -> bool:...
    @property
    def is_reducible(self) -> bool:...
    @property
    def is_reducible_sequence_subclass(self) -> bool:...
    @property
    def is_sequence(self) -> bool:...
    @property
    def is_sequence_subclass(self) -> bool:...
    @property
    def is_slots_type(self) -> bool:...
    @property
    def is_slots_type_sub(self) -> bool:...
    @property
    def is_staticmethod(self) -> bool:...
    @property
    def is_tuple(self) -> bool:...
    @property
    def is_type(self) -> bool:...
    @property
    def is_unicode(self) -> bool:...
def is_even(number: int) -> bool: ...
def join_newline(data: Iterable[str]) -> str: ...
def map_reduce_even(iterable: Iterable[_T]) -> list[_U, list[_T]]:...
def namedinit(cls: Type[Union[NamedAnnotationsType, NamedTuple]], optional: bool = ..., **kwargs) -> NamedTuple: ...
def noexception(
        exception: Union[tuple[Type[Exception]], Type[Exception]],
        func: Callable,
        *args,
        default_: Any = ...,
        **kwargs
) -> Any: ...
def prefixed(name: str) -> str: ...
def repr_format(obj: Any, attrs: Iterable[str], clear: bool = ..., newline: bool = ...) -> str: ...
def split_sep(sep: str = ...) -> dict: ...
def startswith(name: str, builtin: bool = ...) -> bool: ...
def to_iter(data: Any, exclude: Optional[Union[Type, tuple[Union[Type, tuple[Any, ...]], ...]]] = ...) -> list: ...
def varname(index: int = ..., lower: bool = ..., sep: str = ...) -> Optional[str]: ...
def black(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def blue(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def cyan(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def green(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def magenta(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
            blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def red(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
        blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def white(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def yellow(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def bblack(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def bblue(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def bcyan(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def bgreen(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def bmagenta(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
             blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def bred(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def bwhite(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
def byellow(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
            blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None:...
