import os
import pathlib
import pwd
from contextlib import contextmanager
from enum import Enum
from types import ModuleType
from typing import Any
from typing import Generic
from typing import Iterable
from typing import NamedTuple
from typing import Optional
from typing import TypeVar
from typing import Union

import setuptools.command.install
from box import Box
from furl import furl
from git import GitConfigParser
from jinja2 import Template

_P = TypeVar('_Private', bound='Path')
_PI = TypeVar('_PI', bound='PathIs')
_PM = TypeVar('_PM', bound='PathMode')
_POp = TypeVar('_POp', bound='PathOption')
_POu = TypeVar('_POu', bound='PathOutput')
_PS = TypeVar('_PS', bound='PathSuffix')
_PG = TypeVar('_PG', bound='PathGit')
_S  = TypeVar('_S', bound=str)

__all__: tuple
AUTHORIZED_KEYS: str
FILE_DEFAULT: bool
GITCONFIG: str
GITHUB_ORGANIZATION: str
ID_RSA: str
ID_RSA_PUB: str
SSH_CONFIG: dict[str, str]
SSH_CONFIG_TEXT: str
SSH_DIR: str
SUDO_USER: str
SUDO: bool
SUDO_DEFAULT: bool
class PathInstallScript(setuptools.command.install.install):
    def run(self): ...
    @classmethod
    def path(cls) -> str: ...
class PathIs(Enum):
    DIR: _PI
    FILE: _PI
class PathMode(Enum):
    DIR: _PM
    FILE: _PM
    X: _PM
class PathOption(Enum):
    BOTH: _POp
    DIRS: _POp
    FILES: _POp
class PathOutput(Enum):
    BOTH: _POu
    BOX: _POu
    DICT: _POu
    LIST: _POu
    NAMED: _POu
    TUPLE: _POu
class PathSuffix(Enum):
    NO: _PS
    BASH: _PS
    ENV: _PS
    GIT: _PS
    INI: _PS
    J2: _PS
    JINJA2: _PS
    LOG: _PS
    MONGO: _PS
    OUT: _PS
    PY: _PS
    RLOG: _PS
    SH: _PS
    TOML: _PS
    YAML: _PS
    YML: _PS
class Path(pathlib.Path, pathlib.PurePosixPath, Generic[_P], str):
    __slots__ = ('_previous', )
    def __call__(self, name: Optional[str] = ..., file: bool = ...,
                 group: Optional[Union[str, int]] = ...,
                 mode: Optional[Union[int, str]] = ..., su: bool = ...,
                 u: Optional[Union[str, int]] = ...) -> Path: ...
    def __contains__(self, value: Iterable[str]) -> bool: ...
    def __eq__(self, other: Union[Path, tuple[str]]) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def append_text(self, data, encoding=None, errors=None): ...
    @property
    @contextmanager
    def cd(self) -> Path: ...
    def c_(self, p: Any = ...) -> Path: ...
    def chdir(self): ...
    def chmod(self, mode: Optional[Union[int, str]] = ...) -> Path: ...
    def chown(self, group: Optional[Union[str, int]] = ..., u: Optional[Union[str, int]] = ...) -> Path: ...
    @property
    def endseparator(self) -> str: ...
    def fd(self, *args, **kwargs): ...
    @property
    def find_packages(self) -> list: ...
    def find_up(self, file: PathIs = ..., name: Union[str, PathSuffix] = ...) -> FindUp: ...
    def has(self, value: str) -> bool: ...
    @staticmethod
    def home(name: str = ..., file: bool = ...) -> Path: ...
    @property
    def installed(self) -> Path: ...
    @property
    def installedbin(self) -> Path: ...
    @property
    def installedpy(self) -> Path: ...
    def _is_file(self) -> Optional[str]: ...
    def j2(self, dest: Any = ..., stream: bool = ..., variables: dict = ...) -> Union[list, dict]: ...
    def mkdir(self, name: Optional[str] = ..., group: Optional[Union[str, int]] = ...,
              mode: Optional[Union[int, str]] = ..., su: bool = ...,
              u: Optional[Union[str, int]] = ...) -> Path: ...
    @property
    def modname_from_file(self) -> Optional[str]: ...
    @property
    def module_from_file(self) -> Optional[ModuleType]: ...
    @property
    def path(self) -> Path: ...
    @property
    def parent_if_file(self) -> Path: ...
    @property
    def pwd(self) -> Path: ...
    @property
    def read_text_tokenize(self) -> str: ...
    def relative(self, p: Any) -> Path: ...
    @property
    def resolved(self) -> Path: ...
    def rm(self, missing_ok=...): ...
    def scan(self, option: PathOption = ...,
             output: PathOutput = ..., suffix: PathSuffix = ...,
             level: bool = ..., hidden: bool = ..., frozen: bool = ...) -> Union[Box, dict, list]: ...
    @property
    def stemfull(self) -> Path: ...
    @property
    def str(self) -> str: ...
    @classmethod
    def sys(cls) -> Path: ...
    def templates(self, stream: bool = ...) -> dict[str, Union[Template.stream, Template.render]]: ...
    @property
    def text(self) -> str: ...
    @classmethod
    @contextmanager
    def tmp(cls) -> Path: ...
    @staticmethod
    def to_iter(value: Iterable) -> list: ...
    def to_name(self, rel: Path) -> str: ...
    def touch(self, name: Optional[str] = ..., group: Optional[Union[str, int]] = ...,
              mode: Optional[Union[int, str]] = ..., su: bool = ...,
              u: Optional[Union[str, int]] = ...) -> Path: ...
PathLike = os.PathLike
PathLikeStr = Union[PathLike, Path, str]
class PathGit(Enum):
    PATH: _PG
    URL: _PG
    def cmd(self, path: PathLikeStr = ...) -> Optional[Path, furl]: ...
    @classmethod
    def top(cls, path: PathLikeStr = ...) -> GitTop: ...
class UserActual:
    ROOT: bool = ...
    SUDO: bool = ...
    SUDO_USER: str = ...
    def __init__(self) -> None: ...
class UserProcess:
    id: int = ...
    gecos: str = ...
    gid: int = ...
    gname: str = ...
    home: Path = ...
    name: str = ...
    passwd: pwd.struct_passwd = ...
    ROOT: bool = ...
    shell: Path = ...
    ssh: Path = ...
    SUDO: bool = ...
    SUDO_USER: str = ...
    auth_keys: Path = ...
    id_rsa: Path = ...
    id_rsa_pub: Path = ...
    git_config_path: Path = ...
    git_config: GitConfigParser = ...
    github_username: str = ...
class User:
    actual: UserActual = ...
    process: UserProcess = ...
    gecos: str = ...
    gid: int = ...
    gname: str = ...
    home: Path = ...
    id: int = ...
    name: str = ...
    passwd: pwd.struct_passwd = ...
    ROOT: bool = ...
    shell: Path = ...
    ssh: Path = ...
    SUDO: bool = ...
    SUDO_USER: str = ...
    auth_keys: Path = ...
    id_rsa: Path = ...
    id_rsa_pub: Path = ...
    git_config_path: Path = ...
    git_config: GitConfigParser = ...
    github_username: str = ...
    GIT_SSH_COMMAND: str = ...
    def __contains__(self, item: Union[User, str]) -> bool: ...
    def __eq__(self, other: User) -> bool: ...
    def __hash__(self) -> int: ...
    @staticmethod
    def sudo(command, su: bool = ...) -> str: ...
FindUp = NamedTuple('FindUp', path=Optional[Path], previous=Optional[Path])
GitTop = NamedTuple('GitTop', name=str, origin=furl, path=Path)
