import enum
import functools
import itertools
import subprocess as subprocess
import distutils.dist
from contextlib import contextmanager
from typing import Literal
from typing import TextIO

import importlib._bootstrap
from functools import cache
from inspect import FrameInfo
from ipaddress import IPv4Address
from ipaddress import IPv6Address
from os import PathLike
from pathlib import Path
from subprocess import CompletedProcess
from typing import Any
from typing import Callable
from typing import ChainMap
from typing import Hashable
from typing import Iterable
from typing import Mapping
from typing import NamedTuple
from typing import Optional
from typing import overload
from typing import Type
from typing import TypeVar
from typing import Union
import environs
import git as gitpython
import setuptools.command.egg_info
import setuptools.command.install
import setuptools.command.sdist
import sysv_ipc
import typer as typer
import typer.testing
from furl import furl
from loguru._logger import Logger as Logger
from rich import Console
from rich.console import ConsoleOptions
from rich.console import RenderResult
from rich.table import Table
from semver import VersionInfo
from tinydb import TinyDB
from typer import Argument
_T = TypeVar('_T')
__all__: tuple[str, ...] = ...
__file__: str = ...

__spec__: importlib._bootstrap.ModuleSpec = ...
ALL: str = ...
AnyPath = Optional[Union[str, bytes, PathLike, PathLike]]
cachemodule: dict = ...
clirunner: typer.testing.CliRunner
cliinvoke = typer.testing.CliRunner().invoke
FILE: Path = ...
conf: dict[str, Any] = ...
conf_log: dict[str, Any] = ...
Configuration = NamedTuple('Configuration', manifest_in=Path, pyproject_toml=Optional[Path], setup_cfg=Optional[Path],
                           setup_py=Optional[Path])
ExceptionUnion = Union[tuple[Type[Exception]], Type[Exception]]
GITHUB_API_URL: furl = ...
GitUser = NamedTuple('GitUser', blog=furl, email=str, id=int, https=furl, key=str, login=str,  name=str, org=str,
                     pip=furl, repos=furl, ssh=furl, token=str, url=furl)
IPv = Union[IPv4Address, IPv6Address]
LOG: Path = ...
NEWLINE: str = ...
PYTHON_REQUIRES: VersionInfo = ...
TMP: Path = ...
TOOL: str = ...
# Patches
class App(typer.Typer): ...
class LoggerType(Logger):
    cached: Optional[bool] = ...
    configured: bool = ...
    deepcopied: bool = ...
    top_name: str = ...
AnyLogger = Union[Logger, LoggerType]
app: App = ...
logger: AnyLogger = ...
# Enums
class Action(enum.Enum):
    ACQUIRED = ...
    CANCELLED = ...
    CONSUMED = ...
    ERROR = ...
    FINISHED = ...
    LOCKED = ...
    NONE = ...
    PRODUCED = ...
    QUEUED = ...
    RELEASED = ...
    START = ...
    WAITING = ...
    value = tuple[Callable, itertools.count] = ...
class _Pis(enum.Enum):
    def _generate_next_value_(self: str, *args) -> Callable[[Path], Path]: ...
class Pis(_Pis):
    EXISTS = ...
    IS_DIR = ...
    IS_FILE = ...
class _Pname(enum.Enum):
    def _generate_next_value_(self: str, *args) -> Path:...
class Pname(_Pname):
    NONE = ...
    BASH = ...
    CFG = ...
    ENV = ...
    GIT = ...
    GITCONFIG = ...
    INI = ...
    INIT = ...
    INIT_ = ...
    J2 = ...
    JINJA2 = ...
    JSON = ...
    LOG = ...
    MD = ...
    MONGO = ...
    OUT = ...
    PY = ...
    PYI = ...
    PYPROJECT = ...
    README = ...
    REQUIREMENTS = ...
    RLOG = ...
    RST = ...
    SCRIPTS = ...
    SETUP = ...
    SH = ...
    SHELVE = ...
    SSH = ...
    TEMPLATES = ...
    TEST = ...
    TOML = ...
    TXT = ...
    YAML = ...
    YML = ...
    def bash(self, name: str = ...) -> Path: ...
    def cfg(self, name: str = ...) -> Path: ...
    dot: Path = ...
    def env(self, name: str = ...) -> Path: ...
    def git(self, name: str = ...) -> Path: ...
    def j2(self, name: str = ...) -> Path: ...
    def json(self, name: str = ...) -> Path: ...
    def log(self, name: str = ...) -> Path: ...
    def md(self, name: str = ...) -> Path: ...
    name: str = ...
    def py(self, name: str = ...) -> Path: ...
    def pyi(self, name: str = ...) -> Path: ...
    def rlog(self, name: str = ...) -> Path: ...
    def rst(self, name: str = ...) -> Path: ...
    def sh(self, name: str = ...) -> Path: ...
    def test(self, name: str = ...) -> Path: ...
    def toml(self, name: str = ...) -> Path: ...
    def txt(self, name: str = ...) -> Path: ...
    def yml(self, name: str = ...) -> Path: ...
    def yaml(self, name: str = ...) -> Path: ...
# Functions
def copylogger(l:AnyLogger, add: bool = ...) -> AnyLogger: ...
def elementadd(name: Union[str, tuple[str, ...]], closing: Optional[bool] = ...) -> str: ...
def findup(path: AnyPath = None, kind: Pis = ...,
           name: Union[str, Pname, Path, Callable[..., Path]] = ...,
           uppermost: bool = ...) -> Optional[Path]: ...
# noinspection PyShadowingNames
def getlog(e: Optional[Env] = ..., l: Optional[AnyLogger] = ..., extra_add: Optional[Union[str, tuple[str, ...]]] = ...,
           std_add: Optional[Union[str, tuple[str, ...]]] = ..., std_default: bool = ..., copy: bool = ...,
           *,
           trace: Union[str, list[str]] = ..., debug: Union[str, list[str]] = ...,
           info: Union[str, list[str]] = ..., success: Union[str, list[str]] = ...,
           warning: Union[str, list[str]] = ..., error: Union[str, list[str]] = ...,
           critical: Union[str, list[str]] = ...,
           extra: Union[str, list[str]] = ...,
           file: Union[str, list[str]] = ...,
           function: Union[str, list[str]] = ...,
           level: Union[str, list[str]] = ...,
           line: Union[str, list[str]] = ...,
           message: Union[str, list[str]] = ...,
           module: Union[str, list[str]] = ...,
           name: Union[str, list[str]] = ...,
           process: Union[str, list[str]] = ...,
           thread: Union[str, list[str]] = ...,
           time: Union[str, list[str]] = ...,
           colon: Union[str, list[str]] = ...,
           vertical: Union[str, list[str]] = ...) -> AnyLogger: ...
def getstdout(func: Callable, *args: any, ansi: bool = ...,
          new: bool = ..., **kwargs: Any) -> Union[str, Iterable[str, str]]: ...
def is_giturl(remote: Any) -> bool: ...
def jlogload(data: Path = ..., chain: bool = ...) -> Union[ChainMap, list]: ...
def noexc(func: Callable[..., _T], *args: Any, default_: Any = ..., exc_: ExceptionUnion = ...,
          **kwargs: Any) -> Union[_T, Any]: ...
def parent(path: AnyPath = ..., home: bool = ..., tmp: bool = ...) -> Optional[Path]: ...
TMPDIR: Path = ...
def setupls(dirname: Optional[str] = ...) -> Iterable[str]: ...
@overload
def shell(cmd: str, ansi: bool = ..., cwd: AnyPath = ..., environment: Mapping[str, str] = ..., exc: bool = ...,
          executable: Optional[AnyPath] = ..., stdout: bool = ...,
          sudo: bool = ...) -> CompletedProcess[str]: ...
@overload
def shell(cmd: str, ansi: bool = ..., cwd: AnyPath = ..., environment: Mapping[str, str] = ..., exc: bool = ...,
          executable: Optional[AnyPath] = ...,
          sudo: bool = ...) -> Optional[str]: ...
@contextmanager
def stdquiet() -> tuple[TextIO, TextIO]: ...
def strip(data: Union[str, Iterable[str, str]], ansi: bool = ...,
          new: bool = ...) -> Union[str, Iterable[str, str]]: ...
def top(data: Union[int, FrameInfo, AnyPath, Any] = ..., cwd: bool = False) -> Top: ...
class trace:
    cache: dict[Callable, str] = ...
    cls: dict[str, str] = ...
    log: dict[Callable, AnyLogger] = ...
    def __init__(self, l: Optional[AnyLogger] = ..., add_end: tuple[str, ...] = ...,
                 add_start: Optional[Union[bool, tuple[Union[int, str], ...]]] = ..., patch: bool = ...,
                 qual: bool = ..., reraise: bool = ...,
                 method_end: Optional[Callable] = ..., method_start: Optional[Callable] = ...) -> None: ...
    def __call__(self) -> Callable: ...
    def decorating(self, func: Union[Hashable, Callable]) -> Any: ...
# Classes
class Env(environs.Env):
    file: Path = ...
    ignore_case: bool = ...
    prefix: str
    top: Top = ...
    def __init__(self, *, eager: bool = ..., expand_vars: bool = ...,
                 ignore_case: bool = ..., imp_logger: bool = ..., index: int = ...,
                 override: bool = ..., path: AnyPath = ..., prefix: str = ...,
                 use_prefix: bool = ...) -> None: ...
    def __call__(self, name: str, *args: Any, default: Any = ...,
                 subcast: Optional[Union[Type, Callable[..., _T]]] = ..., use_prefix: bool = ...,
                 **kwargs: Any) -> Any: ...
    def __getstate__(self) -> dict[str, Any]: ...
    def __setstate__(self, state: dict[str, Any]) -> None: ...
    def ip(self, name: str, default: Any = ..., exc: bool = ...) -> Optional[Union[IPv, Any]]: ...
    @staticmethod
    def ip_parser(value: str, default: Any = ..., exc: bool = ...) -> Optional[Union[IPv, Any]]: ...
    def furl(self, name: str, default: Any = ..., exc: bool = ...) -> Optional[Union[furl, Any]]: ...
    @staticmethod
    def furl_parser(value: str, default: Any = ..., exc: bool = ...) -> Optional[Union[furl, Any]]: ...
    def level(self, name: str, default: Any = ..., exc: bool = ...,
              use_prefix: bool = ...) -> Optional[Union[str, Any]]: ...
    @staticmethod
    def level_parser(value: str, default: Any = ..., exc: bool = ...) -> Optional[Union[str, Any]]: ...
    level_file: str = ...
    level_json: str = ...
    level_std: str = ...
    def version(self, name: str, default: Any = ..., exc: bool = ...) -> Optional[Union[Version, Any]]: ...
    @staticmethod
    def version_parser(value: str, default: Any = ..., exc: bool = ...) -> Optional[Union[Version, Any]]: ...
env: Env = ...
log: AnyLogger = ...
log_distro: AnyLogger = ...
class _GitHub(enum.Enum):
    @classmethod
    def envvar(cls, name: str, email: bool = ..., token: bool = ...) -> Optional[str]: ...
    @classmethod
    def user(cls, name: str) -> Optional[GitUser]: ...
    def _generate_next_value_(self: str, *args: Any) -> Optional[GitUser]: ...
class GitHub(_GitHub):
    ORG = ...
    USER = ...
    WORK = ...
    _value_: GitUser = ...
    value: GitUser = ...
    @classmethod
    def argument(cls) -> Argument: ...
    @classmethod
    def autocomplete(cls) -> tuple[str, ...]: ...
    @classmethod
    def https(cls, name: str, auth: bool = False) -> furl: ...
    @classmethod
    def organization(cls, name: str) -> Optional[GitHub]: ...
    @classmethod
    def map(cls) -> dict[str, dict[Optional[bool], Union[GitHub, str]]]: ...
    @classmethod
    def pip(cls, name: str, auth: bool = ..., ssh: bool = ...) -> furl: ...
    @classmethod
    def py(cls, name: str) -> bool: ...
    @classmethod
    def pypi(cls, name: str) -> Optional[str]: ...
    @classmethod
    def repos(cls) -> dict[str, Any]: ...
    @classmethod
    def ssh(cls, name: str) -> furl: ...
class Command:
    __slots__: tuple[str, ...] = ...
    @staticmethod
    @app.command()
    def git(data: str = ...) -> None: ...
    @staticmethod
    @app.command()
    def home(data: str = ...) -> None: ...
class Distro:
    __slots__: tuple[str, ...] = ...
    _configuration: Optional[Configuration] = ...
    _doproject: bool = ...
    _git: Optional[gitpython.Repo] = ...
    _github: Optional[GitHub] = ...
    _https: furl = ...
    _manifest_in: Optional[str] = ...
    _name: str = ...
    _packages: dict[str, Path] = ...
    _piphttps: furl = ...
    _pipssh: furl = ...
    _py: bool = ...
    _pypi: Optional[str] = ...
    _requirements: dict[str, Union[tuple[str, ...], dict[str, tuple[str, ...]]]] = ...
    _setup_cfg: Optional[dict[str, Any]]= ...
    _ssh: furl = ...
    _url: Optional[furl] = ...
    _urls: Optional[dict[str, tuple[furl, ...]]] = ...
    action: Action = ...
    default: property = ...
    detached_exc: bool = ...
    doit: bool = ...
    home: Path = ...
    log: AnyLogger = ...
    rm: bool = ...
    table: Table = ...
    def __init__(self, data: AnyPath = ..., clone: bool = ..., detached_exc: bool = ..., doit: bool = ...,
                 rm: bool = ..., ssh: bool = ...) -> None: ...
    def __rich_console__(self, console: Console = ..., options: ConsoleOptions = ...) -> RenderResult: ...
    def _get(self, attr: str) -> Any: ...
    @classmethod
    def all(cls, clone: bool = ..., detached_exc: bool = ..., doit: bool = ...,
                 rm: bool = ..., ssh: bool = ...) -> dict[str, Distro]: ...
    branch: Optional[str] = ...
    branchdefault: Optional[str, dict[str, str]] = ...
    branches: tuple[str, ...] = ...
    def build(self, quiet=True, warning=False) -> None: ...
    def clone(self, rm: bool = ...) -> Optional[gitpython.Repo]: ...
    configuration: Optional[Configuration] = ...
    detached: Optional[bool] = ...
    dirty: Optional[bool] = ...
    doproject: bool = ...
    git: Optional[gitpython.Repo] = ...
    github: Optional[GitHub] = ...
    has_changes: Optional[bool] = ...
    https: Union[furl, property] = ...
    ls: Optional[tuple[Path, ...]] = ...
    manifest_exclude: tuple[str, ...] = ...
    def manifest_in(self) -> Optional[str]: ...
    modules: tuple[str, ...] = ...
    name: str = ...
    packages: dict[str, Path] = ...
    porcelain: Optional[str] = ...
    piphttps: furl = ...
    pipssh: furl = ...
    py: bool = ...
    pypi: Optional[str] = ...
    pyproject_toml: Optional[dict[str, Any]] = ...
    pyproject_toml_load: Optional[dict[str, Any]] = ...
    pyproject_toml_path: Path = ...  # print
    def remotediff(self, branch: Optional[str] = ..., name_only: bool = ..., remote: Optional[str] = ...,
                   stat: bool = ..., **kwargs: Optional[Union[str, bool]]) -> Union[str, dict[str, str]]: ...  # print
    remotes: Optional[tuple[str, ...]] = ...
    requirements: dict[str, Union[tuple[str, ...], dict[str, tuple[str, ...]]]] = ...
    def run(self) -> None: ...
    scripts: dict[str, Path] = ...
    @contextmanager
    def sem(self) -> None: ...
    def setup_cfg(self, verbose: Literal[0, 1, 2, 3] = ...) -> Optional[dict[str, Any]]: ...
    ssh: Union[furl, property] = ...
    tool: dict[str, Any] = ...
    untracked_files: Optional[tuple[str, ...]] = ...
    url: Optional[furl] = ...
    urls: Optional[dict[str, tuple[furl, ...]]] = ...
class egg_info(setuptools.command.egg_info.egg_info):
    def run(self): ...
class install(setuptools.command.install.install):
    dist: distutils.dist.Distribution = ...
    def run(self) -> None: ...
class sdist(setuptools.command.sdist.sdist):
    dist: distutils.dist.Distribution = ...
    def run(self) -> None: ...
class SysSem(sysv_ipc.Semaphore):
    KEY_MIN: int = ...
    KEY_MAX: int = ...
    context: bool = ...
    db: TinyDB = ...
    __slots__: tuple[str, ...] = ...
    log: AnyLogger = ...
    kwargs: dict[str, str] = ...
    def __init__(self, **kwargs: str) -> None: ...
    def __reduce__(self) -> tuple[Type[SysSem, tuple]]: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    @staticmethod
    def purge() -> None: ...
    @contextmanager
    def sem(self) -> None: ...
class Version(VersionInfo):
    _none: Version = ...
    __slots__: tuple[str, ...] = ...
    def __init__(self, major: Union[int, str] = ..., minor: Union[int, str] = ..., patch: Union[int, str] = ...,
                 prerelease: Optional[Union[int, str]] = ..., build: Optional[Union[int, str]] = ...): ...
    git: str = ...
    @classmethod
    def none(cls, version: str = ...) -> Version: ...
    @classmethod
    def parse(cls, version: str = ...) -> Optional[Version]: ...
    text: str = ...
    @classmethod
    @cache
    def versions(cls, versions: Optional[Iterable] = ...) -> Optional[tuple[Version, ...]]: ...
    vtext: str = ...
# Dependencies
Top = NamedTuple('Top', exists=bool, file=Path, git_dir=Optional[Path], init_py=Optional[Path],
                 installed=Optional[bool], jlogfile=Path, jlogload=functools.partial[jlogload], logger=AnyLogger,
                 logfile=Path, name=str, path=Path, prefix=str, pyproject_toml=Optional[Path], rlogfile=Path,
                 root=Path, setup_cfg=Optional[Path], setup_py=Optional[Path], tmp=Path, venv=Path, work=Path)
