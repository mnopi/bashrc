import enum
import functools
import multiprocessing
import subprocess as subprocess
import distutils.dist
import threading
from functools import cache
from typing import ChainMap

import importlib._bootstrap
from inspect import FrameInfo
from ipaddress import IPv4Address
from ipaddress import IPv6Address
from os import PathLike
from pathlib import Path
from subprocess import CompletedProcess
from typing import Any
from typing import Callable
from typing import Hashable
from typing import Iterable
from typing import Mapping
from typing import NamedTuple
from typing import Optional
from typing import overload
from typing import Type
from typing import TypeVar
from typing import Union

import environs
import git as gitpython
import loguru
import setuptools.command.install
import typer as typer
import typer.testing
from furl import furl
from rich import Console
from rich.console import ConsoleOptions
from rich.console import RenderResult
from rich.table import Table
from semver import VersionInfo
from typer import Argument
_T = TypeVar('_T')
__all__: tuple[str, ...] = ...
__file__: str = ...

__spec__: importlib._bootstrap.ModuleSpec = ...
class Action(enum.Enum): ACQUIRED = ...; CANCELLED = ...; CONSUMED = ...; ERROR = ...; FINISHED = ...; LOCKED = ...; \
    NONE = ...; PASS = ...; PRODUCED = ...; QUEUED = ...; RELEASED = ...; START = ...; WAITING = ...
ALL: str = ...
AnyPath = Optional[Union[str, bytes, PathLike, PathLike]]
cachemodule: dict = ...
clirunner: typer.testing.CliRunner
cliinvoke = typer.testing.CliRunner().invoke
FILE: Path = ...
conf: dict[str, Any] = ...
Configuration = NamedTuple('Configuration', pyproject_toml=Optional[Path], setup_cfg=Optional[Path],
                           setup_py=Optional[Path])
ExceptionUnion = Union[tuple[Type[Exception]], Type[Exception]]
GITHUB_API_URL: furl = ...
GitUser = NamedTuple('GitUser', blog=furl, id=int, https=furl, key=str, login=str,  name=str, org=str,
                     pip=furl, repos=furl, ssh=furl, token=str, url=furl)
IPv = Union[IPv4Address, IPv6Address]
LOG: Path = ...
class Logger(loguru.Logger):
    class Core:
        class Handler:
            class Sink:
                _stream: Any = ...
                _flushable: Callable = ...
                _stoppable: Callable = ...
                _completable: bool = ...
                def write(self, message: str) -> None: ...
                def stop(self) -> None: ...
                async def complete(self): ...
            class ErrorInterceptor:
                _should_catch: Optional[bool] = ...
                _handler_id: int = ...
                def should_catch(self): ...
                def print(self, record=None, *, exception=None): ...
            _name: str = ...
            _sink: Sink = ...
            _levelno: int = ...
            _formatter: Union[Callable, str] = ...
            _is_formatter_dynamic: Optional[bool] = ...
            _filter: Callable = ...
            _colorize: Optional[bool] = ...
            _serialize: Optional[bool] = ...
            _enqueue: Optional[bool] = ...
            _error_interceptor: ErrorInterceptor = ...
            _exception_formatter: loguru._better_exceptions.ExceptionFormatter = ...
            _id: int = ...
            _levels_ansi_codes: dict[int, str] = ...
            _decolorized_format: Union[Callable, str] = ...
            _precolorized_formats: dict[int, str] = ...
            _memoize_dynamic_format: Any = ...
            _stopped: bool = ...
            _lock: threading.Lock = ...
            _queue: multiprocessing.SimpleQueue = ...
            _confirmation_event: multiprocessing.Event = ...
            _confirmation_lock: multiprocessing.Lock = ...
            _owner_process_pid: int = ...
            _thread: threading.Thread = ...
            def emit(self, record, level_id, from_decorator, is_raw, colored_message): ...
            def stop(self): ...
            def complete_queue(self): ...
            async def complete_async(self): ...
            def update_format(self, level_id): ...
            @property
            def levelno(self) -> int: ...
            @staticmethod
            def _serialize_record(text, record): ...
            def _queued_writer(self): ...
        levels: dict[str, loguru.Level]
        levels_ansi_codes: dict[Optional[str], str]
        handlers_count: int = ...
        handlers: dict[int, Handler]
        extra: dict[str, Any] = ...
        patcher: Callable = ...
        min_level: float = ...
        enabled: dict[str, Optional[bool]] = ...
        activation_list: list[tuple[str, Optional[bool]]] = ...
        activation_none: Optional[bool] = ...
        lock: threading.Lock = ...
    _core: Core = ...
    _options: tuple = ...
    cached: Optional[bool] = ...
    configured: bool = ...
    deepcopied: bool = ...
    top_name: str = ...
    def _change_activation(self, name, status): ...
    @staticmethod
    def _find_iter(fileobj, regex, chunk): ...
    def _log(self, level_id, static_level_no, from_decorator, options, message, args, kwargs): ...
    @staticmethod
    @functools.lru_cache(maxsize=32)
    def _dynamic_level(level): ...
logger: Logger = ...
class LogCall(enum.Enum): TRACE = Union[enum.Enum, Callable]; DEBUG = Union[enum.Enum, Callable]; \
    INFO = Union[enum.Enum, Callable]; SUCCESS = Union[enum.Enum, Callable]; \
    WARNING = Union[enum.Enum, Callable]; ERROR = Union[enum.Enum, Callable]; \
    CRITICAL = Union[enum.Enum, Callable]
NEWLINE: str = ...
def jlogload(data: Path = ..., chain: bool = ...) -> Union[ChainMap, list]: ...
Top = NamedTuple('Top', exists=bool, file=Path, git_dir=Optional[Path], init_py=Optional[Path], installed=Optional[bool],
                 jlogfile=Path, jlogload=functools.partial[jlogload], logger=Logger, logfile=Path, name=str, path=Path,
                 prefix=str, pyproject_toml=Optional[Path], rlogfile=Path, root=Path, setup_cfg=Optional[Path],
                 setup_py=Optional[Path], tmp=Path, venv=Path, work=Path)
TMP: Path = ...
class App(typer.Typer): ...
app: App = ...
class _Pis(enum.Enum):
    def _generate_next_value_(self: str, *args) -> Callable[[Path], Path]: ...
class Pis(_Pis):
    EXISTS = ...
    IS_DIR = ...
    IS_FILE = ...
class _Pname(enum.Enum):
    def _generate_next_value_(self: str, *args) -> Path:...
class Pname(_Pname):
    NONE = ...
    BASH = ...
    CFG = ...
    ENV = ...
    GIT = ...
    GITCONFIG = ...
    INI = ...
    INIT = ...
    INIT_ = ...
    J2 = ...
    JINJA2 = ...
    JSON = ...
    LOG = ...
    MONGO = ...
    OUT = ...
    PY = ...
    PYI = ...
    PYPROJECT = ...
    REQUIREMENTS = ...
    RLOG = ...
    SCRIPTS = ...
    SETUP = ...
    SH = ...
    SHELVE = ...
    SSH = ...
    TEMPLATES = ...
    TEST = ...
    TOML = ...
    TXT = ...
    YAML = ...
    YML = ...
    def bash(self, name: str = ...) -> Path: ...
    def cfg(self, name: str = ...) -> Path: ...
    @property
    def dot(self) -> Path: ...
    def env(self, name: str = ...) -> Path: ...
    def git(self, name: str = ...) -> Path: ...
    def j2(self, name: str = ...) -> Path: ...
    def json(self, name: str = ...) -> Path: ...
    def log(self, name: str = ...) -> Path: ...
    @property
    def name(self) -> str: ...
    def py(self, name: str = ...) -> Path: ...
    def pyi(self, name: str = ...) -> Path: ...
    def rlog(self, name: str = ...) -> Path: ...
    def sh(self, name: str = ...) -> Path: ...
    def test(self, name: str = ...) -> Path: ...
    def toml(self, name: str = ...) -> Path: ...
    def txt(self, name: str = ...) -> Path: ...
    def yml(self, name: str = ...) -> Path: ...
    def yaml(self, name: str = ...) -> Path: ...
def copylogger(l:Logger, add: bool = ...) -> Logger: ...
def elementadd(name: Union[str, tuple[str, ...]], closing: Optional[bool] = ...) -> str: ...
def findup(path: AnyPath = None, kind: Pis = ...,
           name: Union[str, Pname, Path, Callable[..., Path]] = ...,
           uppermost: bool = ...) -> Optional[Path]: ...
def getlog(e: Optional[Env] = ..., l: Optional[Logger] = ..., extra_add: Optional[Union[str, tuple[str, ...]]] = ...,
           std_add: Optional[Union[str, tuple[str, ...]]] = ..., std_default: bool = ..., copy: bool = ...,
           *,
           trace_: Union[str, tuple[str, ...]] = ..., debug: Union[str, tuple[str, ...]] = ...,
           info: Union[str, tuple[str, ...]] = ..., success: Union[str, tuple[str, ...]] = ...,
           warning: Union[str, tuple[str, ...]] = ..., error: Union[str, tuple[str, ...]] = ...,
           critical: Union[str, tuple[str, ...]] = ..., time: Union[str, tuple[str, ...]] = ...,
           level: Union[str, tuple[str, ...]] = ..., name: Union[str, tuple[str, ...]] = ...,
           function: Union[str, tuple[str, ...]] = ..., line: Union[str, tuple[str, ...]] = ...,
           extra: Union[str, tuple[str, ...]] = ..., message: Union[str, tuple[str, ...]] = ...,
           colon: Union[str, tuple[str, ...]] = ..., vertical: Union[str, tuple[str, ...]] = ...) -> Logger: ...
def getstdout(func: Callable, *args: any, ansi: bool = ...,
          new: bool = ..., **kwargs: Any) -> Union[str, Iterable[str, str]]: ...
def is_giturl(remote: Any) -> bool: ...
def noexc(func: Callable[..., _T], *args: Any, default_: Any = ..., exc_: ExceptionUnion = ...,
          **kwargs: Any) -> Union[_T, Any]: ...
def parent(path: AnyPath = ..., home: bool = ..., tmp: bool = ...) -> Optional[Path]: ...
TMPDIR: Path = ...
@overload
def shell(cmd: str, ansi: bool = ..., cwd: AnyPath = ..., environment: Mapping[str, str] = ..., exc: bool = ...,
          executable: Optional[AnyPath] = ..., stdout: bool = ...,
          sudo: bool = ...) -> CompletedProcess[str]: ...
@overload
def shell(cmd: str, ansi: bool = ..., cwd: AnyPath = ..., environment: Mapping[str, str] = ..., exc: bool = ...,
          executable: Optional[AnyPath] = ...,
          sudo: bool = ...) -> Optional[str]: ...
def strip(data: Union[str, Iterable[str, str]], ansi: bool = ...,
          new: bool = ...) -> Union[str, Iterable[str, str]]: ...
def top(data: Union[int, FrameInfo, AnyPath, Any] = ..., cwd: bool = False) -> Top: ...
class trace:
    cache: dict[Callable, str] = ...
    cls: dict[str, str] = ...
    log: dict[Callable, Logger] = ...
    def __init__(self, l: Optional[Logger] = ..., add_end: tuple[str, ...] = ...,
                 add_start: Union[bool, tuple[Union[int, str], ...]] = ...,
                 patch: bool = ..., qual: bool = ..., reraise: bool = ...,
                 *,
                 start: Optional[Union[LogCall, Callable]] = ...,
                 acquired: Union[LogCall, Callable] = ..., finish: Union[LogCall, Callable] = ...,
                 pass_: Union[LogCall, Callable] = ...,
                 produced: Union[LogCall, Callable] = ..., released: Union[LogCall, Callable] = ...,
                 waiting: Union[LogCall, Callable] = ...) -> None: ...
    def __call__(self) -> Callable: ...
    def decorating(self, func: Union[Hashable, Callable]) -> Any: ...
class Env(environs.Env):
    file: Path = ...
    ignore_case: bool = ...
    prefix: str
    top: Top = ...
    def __init__(self, *, eager: bool = ..., expand_vars: bool = ...,
                 ignore_case: bool = ..., imp_logger: bool = ..., index: int = ...,
                 override: bool = ..., path: AnyPath = ..., prefix: str = ...,
                 use_prefix: bool = ...) -> None: ...
    def __call__(self, name: str, *args: Any, default: Any = ...,
                 subcast: Optional[Union[Type, Callable[..., _T]]] = ..., use_prefix: bool = ...,
                 **kwargs: Any) -> Any: ...
    def __getstate__(self) -> dict[str, Any]: ...
    def __setstate__(self, state: dict[str, Any]) -> None: ...
    def ip(self, name: str, default: Any = ..., exc: bool = ...) -> Optional[Union[IPv, Any]]: ...
    @staticmethod
    def ip_parser(value: str, default: Any = ..., exc: bool = ...) -> Optional[Union[IPv, Any]]: ...
    def furl(self, name: str, default: Any = ..., exc: bool = ...) -> Optional[Union[furl, Any]]: ...
    @staticmethod
    def furl_parser(value: str, default: Any = ..., exc: bool = ...) -> Optional[Union[furl, Any]]: ...
    def level(self, name: str, default: Any = ..., exc: bool = ...,
              use_prefix: bool = ...) -> Optional[Union[str, Any]]: ...
    @staticmethod
    def level_parser(value: str, default: Any = ..., exc: bool = ...) -> Optional[Union[str, Any]]: ...
    level_file: str = ...
    level_std: str = ...
    def version(self, name: str, default: Any = ..., exc: bool = ...) -> Optional[Union[Version, Any]]: ...
    @staticmethod
    def version_parser(value: str, default: Any = ..., exc: bool = ...) -> Optional[Union[Version, Any]]: ...
env: Env = ...
log: Logger = ...
class _GitHub(enum.Enum):
    _all: str = ...
    _argument: Argument = ...
    _autocomplete: tuple[str, ...] = ...
    _default: str = ...
    _repos: dict[str, Any] = ...
    @classmethod
    def envvar(cls, name: str, token: bool = ...) -> Optional[str]: ...
    @classmethod
    def user(cls, name: str) -> Optional[GitUser]: ...
    def _generate_next_value_(self: str, *args: Any) -> Optional[GitUser]: ...
class GitHub(_GitHub):
    ORG = ...
    USER = ...
    WORK = ...
    _value_: GitUser = ...
    value: GitUser = ...
    @classmethod
    def argument(cls) -> Argument: ...
    @classmethod
    def autocomplete(cls) -> tuple[str, ...]: ...
    @classmethod
    def https(cls, name: str, auth: bool = False) -> furl: ...
    @classmethod
    def map(cls) -> dict[str, dict[Optional[bool], Union[GitHub, str]]]: ...
    @classmethod
    def pip(cls, name: str, auth: bool = ..., ssh: bool = ...) -> furl: ...
    @classmethod
    def py(cls, name: str) -> bool: ...
    @classmethod
    def pypi(cls, name: str) -> Optional[str]: ...
    @classmethod
    def repos(cls) -> dict[str, Any]: ...
    @classmethod
    def ssh(cls, name: str) -> furl: ...
class Command:
    __slots__: tuple[str, ...] = ...
    @staticmethod
    @app.command()
    def git(data: str = ...) -> None: ...
    @staticmethod
    @app.command()
    def home(data: str = ...) -> None: ...
class Distro:
    __slots__: tuple[str, ...] = ...
    _configuration: Configuration = ...
    _doproject: bool = ...
    _dict: dict[str, Any] = ...
    _git: Optional[gitpython.Repo] = ...
    _https: furl = ...
    _modules: dict[str, Path] = ...
    _name: str = ...
    _packages: dict[str, Path] = ...
    _piphttps: furl = ...
    _pipssh: furl = ...
    _py: bool = ...
    _pypi: Optional[str] = ...
    _pyproject_toml: Optional[dict[str, Any]] = ...
    _setup: Optional[dict[str, Any]] = ...
    _setup_cfg: Optional[Path] = ...
    _ssh: furl = ...
    _url: Optional[furl] = ...
    _urls: Optional[dict[str, tuple[furl, ...]]] = ...
    default: property = ...
    detached_exc: bool = ...  # print
    doit: bool = ...  # print
    home: Path = ...  # print
    rm: bool = ...  # print
    table: Table = ...
    def __init__(self, data: AnyPath = ..., clone: bool = ..., detached_exc: bool = ..., doit: bool = ...,
                 rm: bool = ..., ssh: bool = ...) -> None: ...
    def __rich_console__(self, console: Console = ..., options: ConsoleOptions = ...) -> RenderResult: ...
    def _get(self, attr: str) -> Any: ...
    branch: Optional[str] = ...  # print
    branchdefault: Optional[str, dict[str, str]] = ...  # print
    branches: tuple[str, ...] = ...  # print
    def build(self) -> None: ...
    def clone(self, rm: bool = ...) -> None: ...
    configuration: Configuration = ...  # print
    detached: Optional[bool] = ...  # print
    dict: dict[str, Any] = ...  # print
    dirty: Optional[bool] = ...  # print
    doproject: bool = ...  # print
    git: Optional[gitpython.Repo] = ...
    has_changes: Optional[bool] = ...  # print
    https: Union[furl, property] = ...
    ls: Optional[tuple[Path, ...]] = ...
    def manifest(self) -> None: ...
    modules: dict[str, Path] = ...  # print
    name: str = ...  # print
    packages: dict[str, Path] = ...  # print
    porcelain: Optional[str] = ...  # print
    piphttps: furl = ...
    pipssh: furl = ...
    py: bool = ...
    pypi: Optional[str] = ...
    pyproject_toml: Optional[dict[str, Any]] = ...  # print
    def remotediff(self, branch: Optional[str] = ..., name_only: bool = ..., remote: Optional[str] = ...,
                   stat: bool = ..., **kwargs: Optional[Union[str, bool]]) -> Union[str, dict[str, str]]: ...  # print
    remotes: Optional[tuple[str, ...]] = ...  # print
    requirements: dict[str, Union[tuple[str, ...], dict[str, dict[str, tuple[str, ...]]]]] = ...  # print
    def run(self) -> None: ...
    scripts: dict[str, Path] = ...  # print
    def setup(self) -> Optional[dict[str, Any]]: ...  # print
    setup_cfg: Optional[Path] = ...  # print
    ssh: Union[furl, property] = ...
    untracked_files: Optional[tuple[str, ...]] = ...  # print
    url: Optional[furl] = ...  # print
    urls: Optional[dict[str, tuple[furl, ...]]] = ...
class Install(setuptools.command.install.install):
    dist: distutils.dist.Distribution = ...
    def run(self) -> None: ...
class Version(VersionInfo):
    _none: Version = ...
    __slots__: tuple[str, ...] = ...
    def __init__(self, major: Union[int, str] = ..., minor: Union[int, str] = ..., patch: Union[int, str] = ...,
                 prerelease: Optional[Union[int, str]] = ..., build: Optional[Union[int, str]] = ...): ...
    git: str = ...
    @classmethod
    def none(cls, version: str = ...) -> Version: ...
    @classmethod
    def parse(cls, version: str = ...) -> Optional[Version]: ...
    text: str = ...
    @classmethod
    @cache
    def versions(cls, versions: Optional[Iterable] = ...) -> Optional[tuple[Version, ...]]: ...
    vtext: str = ...
